function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}

function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}

function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}

import {
    cssStringToObject,
    get
} from '../../utils/utils';
import {
    getImageComputedProperties,
    getImageSrc,
    getMaskBBox
} from '../../utils/imageUtils';
import {
    getScreenHeight,
    setAttributes,
    setStyle
} from '../../utils/domUtils';
import biEvents from './bi/events';
var MOBILE_SAFE_ADDRESSBAR_HEIGHT = 80;

function getDefaultStyles(style) {
    var _style = style,
        width = _style.width,
        height = _style.height,
        styleWithoutDimensions = _objectWithoutPropertiesLoose(_style, ["width", "height"]); // eslint-disable-line no-unused-vars


    var stylesWithValue = {};

    for (style in styleWithoutDimensions) {
        if (styleWithoutDimensions[style] !== '') {
            stylesWithValue[style] = styleWithoutDimensions[style];
        }
    }

    return stylesWithValue;
}

function getContainerStyle(style, opacity) {
    var styleWithoutDefaults = getDefaultStyles(style);

    if (typeof opacity === 'number') {
        styleWithoutDefaults.opacity = opacity;
    }

    return styleWithoutDefaults;
}

function getHeightOverride(mediaHeightOverrideType, height) {
    // on mobile, document client height vary when scrolling, address bar is collapsing.
    // avoiding re-fetching image by returning the same height
    return mediaHeightOverrideType === 'fixed' || mediaHeightOverrideType === 'viewport' ? document.documentElement.clientHeight + MOBILE_SAFE_ADDRESSBAR_HEIGHT : height;
}
/**
 * siteBackground on mobile specific overrides
 * @param mediaHeightOverrideType
 * @param imageStyle
 * @param displayMode
 * @returns {*} style object
 */


function computeStyleOverrides(mediaHeightOverrideType, imageStyle, displayMode) {
    if (!mediaHeightOverrideType) {
        return imageStyle;
    }

    var style = Object.assign({}, imageStyle);

    if (displayMode === 'fill') {
        style.position = 'absolute';
        style.top = 0;
    }

    if (displayMode === 'fit') {
        style.height = '100%';
    }

    if (mediaHeightOverrideType === 'fixed') {
        // eliminates white gap when address bar is collapsing
        style['will-change'] = 'transform';
    } //force image alignment to include top


    if (style.objectPosition) {
        style.objectPosition = imageStyle.objectPosition.replace(/(center|bottom)$/, 'top');
    }

    return style;
}

function sendBiEvent(biService, envConsts, imageInfo, imageToLoad, imageComputedProperties) {
    // should send Bi Event if we are on viewer, url includes upscale value lg_
    var upscaleMatcher = /,lg_(\d)/;
    var upscaleResult = imageComputedProperties.uri.match(upscaleMatcher);
    var shouldSendBiEvent = envConsts.isViewerMode && imageComputedProperties.uri !== imageToLoad.currentSrc && upscaleResult;

    if (shouldSendBiEvent) {
        biService.reportBI(biEvents.IMAGE_UPSCALING, {
            originalWidth: imageInfo.imageData.width,
            originalHeight: imageInfo.imageData.height,
            targetWidth: Math.round(imageInfo.targetWidth),
            targetHeight: Math.round(imageInfo.targetHeight),
            upscaleMethod: upscaleResult[1] === '1' ? 'classic' : 'super',
            devicePixelRatio: Math.floor(envConsts.devicePixelRatio * 100),
            url: imageToLoad.src
        });
    }
}

function measure(id, measures, domNodes, _ref, services) {
    var containerElm = _ref.containerElm,
        isSvgImage = _ref.isSvgImage,
        isSvgMask = _ref.isSvgMask,
        mediaHeightOverrideType = _ref.mediaHeightOverrideType,
        bgEffectName = _ref.bgEffectName;
    var innerImage = domNodes.image;
    var wixImage = domNodes[id];
    var screenHeight = getScreenHeight();
    var sourceOfDimensions = containerElm && bgEffectName ? containerElm : wixImage; // default to self

    var _services$getMediaDim = services.getMediaDimensionsByEffect(bgEffectName, sourceOfDimensions.offsetWidth, sourceOfDimensions.offsetHeight, screenHeight),
        width = _services$getMediaDim.width,
        height = _services$getMediaDim.height;

    if (!innerImage) {
        return;
    }

    var imgSrc = getImageSrc(innerImage, isSvgImage);
    measures.width = width;
    measures.screenHeight = screenHeight;
    measures.height = getHeightOverride(mediaHeightOverrideType, height);
    measures.isZoomed = wixImage.getAttribute('data-image-zoomed');
    measures.isSvgImage = isSvgImage;
    measures.imgSrc = imgSrc;
    measures.renderedStyles = wixImage.getAttribute('data-style');
    measures.boundingRect = wixImage.getBoundingClientRect();
    measures.mediaHeightOverrideType = mediaHeightOverrideType;

    if (isSvgMask) {
        measures.bBox = getMaskBBox(domNodes.maskSvg);
    }
}

function patch(id, measures, domNodes, imageInfo, services, envConsts, loadImage, bgEffectName) {
    if (!Object.keys(measures).length) {
        return;
    }

    var style = cssStringToObject(measures.renderedStyles);
    var imageData = imageInfo.imageData; // no retina scaling for background scroll effects

    if (bgEffectName) {
        imageData.devicePixelRatio = 1;
    }

    var extendedImageInfo = Object.assign({}, imageInfo, _objectSpread(_objectSpread({}, imageInfo.skipMeasure ? {} : {
        targetWidth: measures.isZoomed ? imageData.width : measures.width,
        targetHeight: measures.isZoomed ? imageData.height : measures.height
    }), {}, {
        displayMode: imageData.displayMode
    }));
    var imageComputedProperties;

    if (measures.isSvgImage) {
        imageComputedProperties = getImageComputedProperties(extendedImageInfo, envConsts, 'svg');
        setAttributes(domNodes.svg, measures.isZoomed ? imageComputedProperties.attr.container : {});
    } else {
        imageComputedProperties = getImageComputedProperties(extendedImageInfo, envConsts, 'img'); //compute style

        var computedStyle = get(imageComputedProperties, ['css', 'img']) || {};
        var imageStyle = computeStyleOverrides(measures.mediaHeightOverrideType, computedStyle, imageData.displayMode);
        setStyle(domNodes.image, imageStyle);
    }

    if (measures.bBox && domNodes.maskSvg) {
        setAttributes(domNodes.maskSvg, {
            viewBox: measures.bBox
        });
    }

    var containerStyle = getContainerStyle(style, imageData.opacity);
    setStyle(domNodes[id], containerStyle);
    var src = get(imageComputedProperties, 'uri'); //this was always like this (using _.get) and it looks like videoThumb images for wixapps explodes here since they dont have a uri -> no imageTransformProps

    var currentSrc = measures.imgSrc;
    setAttributes(domNodes[id], {
        'data-src': src
    }); //clear initial indication that the image src came from ssr render

    setAttributes(domNodes[id], {
        'data-has-ssr-src': ''
    });

    if (loadImage) {
        sendBiEvent(services.biService, envConsts, extendedImageInfo, {
            src: src,
            currentSrc: currentSrc
        }, imageComputedProperties);
        services.imageLoader.loadImage(domNodes[id], {
            screenHeight: measures.screenHeight,
            boundingRect: measures.boundingRect
        });
    }
}

export default {
    measure: measure,
    patch: patch
};
//# sourceMappingURL=imageLayout.js.map