(self.webpackJsonp__wix_thunderbolt_app = self.webpackJsonp__wix_thunderbolt_app || []).push([
    [8450], {
        30313: function(t, e, n) {
            "use strict";
            n.r(e), n.d(e, {
                ScreenInAPISymbol: function() {
                    return l.JC
                },
                page: function() {
                    return A
                }
            });
            var i = n(25259),
                s = n(29547),
                o = n(21980),
                a = n(82168),
                r = n(56510),
                c = n(7611),
                d = n(31191);
            const m = t => `${t}-screenIn`;
            class p {
                constructor(t) {
                    this.animator = t, this.definitions = {}, this.sessionState = {
                        played: new Map,
                        running: new Map
                    }
                }
                _shouldSkipPlayedAnimation(t) {
                    const e = this.sessionState.played.has(t),
                        {
                            playOnce: n,
                            persistOnNav: i
                        } = this.sessionState.played.get(t) || {};
                    return e && (n || i)
                }
                _hideComponent(t) {
                    const e = document.querySelector(`#${t}`);
                    e && (e.style.opacity = 0)
                }
                unhideComponent(t) {
                    const e = document.querySelector(`#${t}`);
                    e && (e.dataset.screenInHide = "done", e.style.opacity = "", e.style.visibility = "inherit")
                }
                _addAnimatingClass(t) {
                    const e = document.getElementById(t);
                    e && (e.classList.add("is-animating"), e.dataset.screenInHide = "done")
                }
                _removeAnimatingClass(t) {
                    const e = document.getElementById(t);
                    e && (e.classList.remove("is-animating"), e.dataset.screenInHide = "done")
                }
                updateDefinitions(t) {
                    this.definitions = Object.assign(Object.assign({}, this.definitions), t)
                }
                _hideCompBeforeAnimation(t) {
                    const e = m(t);
                    this._shouldSkipPlayedAnimation(e) ? this.unhideComponent(t) : this._hideComponent(t)
                }
                hideBeforeAnimation(t) {
                    this.getCompsToHide(t).forEach((({
                        compId: t
                    }) => {
                        this._hideCompBeforeAnimation(t)
                    }))
                }
                handleRotation(t, e) {
                    t.setAttribute("data-angle", String(e)), t.setAttribute("data-angle-style-location", "style")
                }
                trigger(t = []) {
                    t.reduce(((t, {
                        compId: e
                    }) => {
                        const n = this.definitions[e] || [];
                        return t.concat(n)
                    }), []).forEach((t => {
                        var {
                            action: e
                        } = t, n = (0, d._T)(t, ["action"]);
                        return this.executeAnimation(e, n)
                    }))
                }
                init(t) {
                    this.updateDefinitions(t), this.stopAnimations(), this.hideBeforeAnimation(t)
                }
                addDefinition(t, e, n) {
                    this.handleRotation(e, n), this.updateDefinitions(t)
                }
                executeAnimation(t, {
                    name: e,
                    targetId: n,
                    duration: i = 0,
                    delay: s = 0,
                    playOnce: o = !1,
                    persistOnNav: a = !1,
                    params: r = {}
                }) {
                    const c = m(n);
                    if (this._shouldSkipPlayedAnimation(c)) return void this.unhideComponent(n);
                    const d = {
                            name: e,
                            targetId: n,
                            duration: i,
                            delay: s,
                            params: r
                        },
                        p = {
                            name: "BaseClear",
                            targetId: n,
                            duration: 0,
                            delay: 0,
                            params: {
                                props: "clip,clipPath,webkitClipPath,willChange,opacity,transform,transformOrigin",
                                immediateRender: !1
                            }
                        };
                    this.animator.runSequence([{
                        type: "Animation",
                        data: d
                    }, {
                        type: "Animation",
                        data: p
                    }], {
                        callbacks: {
                            onStart: e => {
                                this._addAnimatingClass(n), this.sessionState.running.set(e, {
                                    targetId: n,
                                    action: t
                                })
                            },
                            onComplete: t => {
                                this._removeAnimatingClass(n), this.sessionState.running.delete(t)
                            },
                            onInterrupt: t => {
                                this._removeAnimatingClass(n), this.sessionState.running.delete(t)
                            }
                        }
                    }), this.sessionState.played.set(c, {
                        playOnce: o,
                        persistOnNav: a
                    })
                }
                stopAnimations({
                    skipPersistent: t = !0
                } = {}) {
                    this.sessionState.running.forEach((({
                        targetId: e
                    }, n) => {
                        const i = m(e);
                        t && this.sessionState.played.get(i).persistOnNav || this.animator.kill(n, 1)
                    }))
                }
                getAnimationProperties(t) {
                    return this.animator.getAnimationProperties(t)
                }
                getCompsToHide(t) {
                    return Object.entries(t).reduce(((t, [e, n]) => (n.some((({
                        name: t
                    }) => {
                        const e = this.animator.getAnimationProperties(t);
                        return e && e.hideOnStart
                    })) && t.push({
                        compId: e
                    }), t)), [])
                }
                clearState() {
                    this.sessionState.played.clear(), this.sessionState.running.clear()
                }
            }
            var l = n(90863);

            function u({
                manager: t
            }) {
                const e = {};

                function n(e) {
                    const n = e.filter((t => t.visible)).map((t => ({
                        compId: t.id,
                        action: "screenIn"
                    })));
                    t.trigger(n)
                }

                function i(t, i) {
                    const s = e[i] || function(t, e) {
                        const n = {
                            root: null,
                            rootMargin: "0px",
                            threshold: [e]
                        };
                        return new window.IntersectionObserver((function(e, n) {
                            const i = e.map((t => ({
                                visible: t.isIntersecting,
                                ratio: t.intersectionRatio,
                                rect: t.intersectionRect,
                                id: t.target.id
                            })));
                            e.forEach((t => t.isIntersecting && n.unobserve(t.target))), t(i)
                        }), n)
                    }(n, i);
                    s.observe(t), e[i] || (e[i] = s)
                }
                return {
                    start: function(e, n, s) {
                        const o = window.innerHeight;
                        if (n) {
                            const e = n.offsetHeight > o ? .01 : function(t, e) {
                                return t.getAnimationProperties(e).viewportThreshold
                            }(t, s) || 0;
                            i(n, e)
                        }
                    }
                }
            }
            var h = n(52192);
            const g = (0, r.ff)([(0, r.t6)(i.$e, l.u2), (0, r.t6)(i.Wf, l.u2), s.m, o.ZQ, a.C, (0, r.jt)(c.FK)], ((t, e, n, i, s, o) => () => {
                    const {
                        compIdToActions: a,
                        compIdToRotations: r
                    } = t;
                    if (n && !(0, h.yF)(i)) return void Object.keys(a).forEach((async t => {
                        await s.waitForComponentToRender(t), p.prototype.unhideComponent(t)
                    }));
                    if (!o) return;
                    const c = o.getInstance().then((t => {
                        var n, i;
                        const s = null !== (i = null === (n = e.get()) || void 0 === n ? void 0 : n.screenInManager) && void 0 !== i ? i : new p(t);
                        s.init(a);
                        const o = u({
                            manager: s
                        });
                        return e.update((t => Object.assign(Object.assign({}, t), {
                            screenInManager: s,
                            viewport: o
                        }))), {
                            animations: o,
                            screenInManager: s
                        }
                    }));
                    return async (t, e, i) => {
                        if (!i) return;
                        const {
                            animations: s,
                            screenInManager: o
                        } = await c;
                        if (n) return void o.unhideComponent(t);
                        let d = a[t];
                        if (e !== t) {
                            const t = JSON.parse(JSON.stringify(d));
                            t[0].targetId = e, d = t
                        }
                        o.addDefinition({
                            [e]: d
                        }, i, r[t]), s.start(e, i, d[0].name)
                    }
                })),
                f = (0, r.ff)([(0, r.t6)(i.$e, l.u2), l.cL, a.C], ((t, e, n) => ({
                    name: "screenInInit",
                    pageWillMount() {
                        const i = e();
                        if (!i) return;
                        const s = Object.keys(t.compIdToActions || {});
                        n.registerToCompLifeCycle(s, l.IA, i)
                    }
                }))),
                y = (0, r.ff)([(0, r.t6)(i.$e, l.u2), (0, r.t6)(i.Wf, l.u2), a.C, s.m], ((t, e, n, i) => ({
                    pageWillUnmount() {
                        if (!i) {
                            const e = Object.keys(t.compIdToActions || {});
                            n.unregisterToCompLifeCycle(e, l.IA)
                        }
                    }
                })));
            var I = n(13487);
            const A = t => {
                t(l.cL).to(g), t(I.j.PageWillMountHandler).to(f), t(I.j.PageWillUnmountHandler).to(y)
            }
        }
    }
]);
//# sourceMappingURL=https://static.parastorage.com/services/wix-thunderbolt/dist/screenIn.35cdb756.chunk.min.js.map