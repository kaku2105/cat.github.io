(self.webpackJsonp__wix_thunderbolt_app = self.webpackJsonp__wix_thunderbolt_app || []).push([
[7955], {
    39013: function(e, t, n) {
        "use strict";
        n.d(t, {
            $E: function() {
                return s
            },
            $H: function() {
                return p
            },
            Xr: function() {
                return l
            }
        });
        var i = n(56510),
            a = n(21980),
            o = n(18325);
        const r = {},
            s = "TPA_PUB_SUB_";

        function p(e) {
            const t = new RegExp(`^${s}`);
            return e.replace(t, "")
        }
        const l = (0, i.ff)([a.ZQ, o.ku], ((e, t) => {
            function n(e, t) {
                const n = {
                    persistentData: [],
                    listeners: {}
                };
                return r[e] ? r[e][t] || (r[e][t] = n) : r[e] = {
                    [t]: n
                }, r[e][t]
            }

            function i(e) {
                Object.keys(r).forEach((t => {
                    Object.keys(r[t]).forEach((i => {
                        const a = n(t, i);
                        Object.entries(a.listeners).forEach((([t, n]) => {
                            Object.keys(n).forEach((n => {
                                e(n, t) && delete a.listeners[t][n]
                            }))
                        }))
                    }))
                }))
            }
            return {
                publish(e, t, i) {
                    const a = p(i.eventKey),
                        o = i.isPersistent,
                        r = n(e, a),
                        s = r.listeners;
                    if (Object.entries(s).forEach((([e, n]) => Object.keys(n).forEach((n => {
                            s[e][n].forEach((e => e({
                                data: i.eventData,
                                name: a,
                                origin: t
                            })))
                        })))), o) {
                        const e = i.eventData;
                        r.persistentData.push({
                            name: a,
                            data: e
                        })
                    }
                },
                subscribe(e, i, a, o) {
                    const r = p(a.eventKey),
                        s = n(e, r);
                    s.listeners[t] || (s.listeners[t] = {}), s.listeners[t][i] ? "worker" === i && s.listeners[t][i].push(o) : s.listeners[t][i] = [o], a.isPersistent && s.persistentData.length && o({
                        data: s.persistentData[0].data,
                        name: r,
                        origin: i
                    }, !0)
                },
                unsubscribe(e, t, i) {
                    const a = n(e, p(i));
                    Object.keys(a.listeners).forEach((e => {
                        delete a.listeners[e][t]
                    }))
                },
                handleIframeSubscribe(t, n, {
                    eventKey: i,
                    isPersistent: a,
                    callId: o
                }) {
                    this.subscribe(t, n, {
                        eventKey: i,
                        isPersistent: a
                    }, ((t, a = !1) => {
                        ! function(e, t, n) {
                            const i = n.document.getElementById(e);
                            if (!i) return;
                            const a = i.getElementsByTagName("iframe")[0];
                            a && a.contentWindow && a.contentWindow.postMessage(JSON.stringify(t), "*")
                        }(n, a ? {
                            intent: "TPA_RESPONSE",
                            callId: o,
                            type: "registerEventListener",
                            res: {
                                drain: !0,
                                data: [t]
                            },
                            status: !0,
                            compId: n
                        } : {
                            eventType: i,
                            intent: "addEventListener",
                            params: t
                        }, e)
                    }))
                },
                clearListenersBesideStubs() {
                    i(((e, n) => !e.includes("tpapopup") && !e.includes("tpaWorker") && n === t && "masterPage" !== n))
                },
                clearListenersByCompId(e) {
                    i((t => t === e))
                }
            }
        }))
    },
    90012: function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, {
            SiteMapSymbol: function() {
                return l.Cc
            },
            TpaEventsListenerManagerSymbol: function() {
                return l.PV
            },
            TpaFullScreenModeSymbol: function() {
                return l.u5
            },
            TpaModalSymbol: function() {
                return l.R3
            },
            TpaPopupSymbol: function() {
                return a.jn
            },
            TpaSymbol: function() {
                return l.e4
            },
            name: function() {
                return l.u2
            },
            page: function() {
                return Rn
            }
        });
        var i = n(13487),
            a = n(46450),
            o = n(21980),
            r = n(56510),
            s = n(25259),
            p = n(55437),
            l = n(3338),
            d = n(64318);
        const c = "_rtby_",
            u = {
                buildRuntimeCompId: (e, t) => `${e}_rtby_${t}`,
                isRuntimeCompId: e => e.split(c).length > 1,
                getOriginCompId(e) {
                    const [t, n] = e.split(c);
                    return n || t
                }
            };
        var g = n(41906),
            m = n(60008);
        const f = Symbol("TPA_HANDLER_EMPTY_RESPONSE"),
            h = {
                WIX_CHAT: "14517e1a-3ff0-af98-408e-2bd6953c36a2",
                WIX_RESTAURANTS: "13e8d036-5516-6104-b456-c8466db39542"
            },
            I = "PageLink",
            P = "ExternalLink",
            y = "AnchorLink",
            w = "EmailLink",
            T = "PhoneLink",
            v = "WhatsAppLink",
            b = "DocumentLink",
            C = "DynamicPageLink",
            S = "AddressLink",
            O = "MenuHeader",
            D = (0, r.ff)([(0, r.t6)(s.R9, d.u2), (0, r.t6)(s.$e, l.u2), (0, r.fi)(a.go), p.xP, o.ZQ, o.Zr, (0, r.jt)(m.m), (0, r.jt)(g.KO)], ((e, t, n, i, a, {
                mode: {
                    debug: o
                }
            }, r, s) => {
                const {
                    appsClientSpecMapData: p
                } = e, l = ({
                    tpa: e,
                    origin: n,
                    callId: i,
                    status: a,
                    res: o,
                    compId: r
                }) => {
                    const p = {
                        callId: i,
                        intent: "TPA_RESPONSE",
                        status: a,
                        res: o
                    };
                    s && s.tpa.addMessage({
                        message: p,
                        compId: r,
                        contextId: t.pageId,
                        origin: n
                    }), e.postMessage(JSON.stringify(p), "*")
                }, d = Object.assign({}, ...n.map((e => e.getTpaHandlers())));
                return {
                    async handleMessage({
                        source: n,
                        origin: a,
                        message: s
                    }) {
                        const {
                            type: c,
                            callId: g,
                            compId: m,
                            data: h,
                            deviceType: I,
                            originFrame: P
                        } = s, y = (e => {
                            var t, n;
                            const a = (null === (t = i.get(e)) || void 0 === t ? void 0 : t.src) || (null === (n = i.get(e)) || void 0 === n ? void 0 : n.url);
                            return a ? new URL(a) : null
                        })(m);
                        if ("https://static.parastorage.com" !== a && !((e, t) => (null == e ? void 0 : e.origin) === t)(y, a) && !(e => "https://editor.wix.com" === e || "https://create.editorx.com" === e || "https://blocks.wix.com" === e)(a)) return void(o && console.warn("discarded tpa message: untrusted origin", {
                            origin: a,
                            message: s
                        }));
                        const w = d[c];
                        if (!w) return void(o && console.warn(`TpaHandlerError: ${c} handler is not implemented`));
                        const T = u.getOriginCompId(m),
                            v = t.widgets[T],
                            b = null == r ? void 0 : r.isTpaWorker(m),
                            C = b ? r.getWorkerDetails(m) : null,
                            S = b ? C.appDefinitionId : null == v ? void 0 : v.appDefinitionId,
                            O = w(m, h, {
                                callId: g,
                                tpa: n,
                                appDefinitionId: S,
                                tpaCompData: v,
                                appClientSpecMapData: p[S],
                                originCompId: T,
                                viewMode: e.viewMode
                            });
                        if (void 0 !== O) try {
                            const e = await O;
                            if (e === f) return;
                            l({
                                tpa: n,
                                origin: a,
                                callId: g,
                                compId: m,
                                status: !0,
                                res: e
                            })
                        } catch (e) {
                            const {
                                message: t,
                                name: i,
                                stack: o
                            } = e;
                            l({
                                tpa: n,
                                origin: a,
                                callId: g,
                                compId: m,
                                status: !1,
                                res: {
                                    error: {
                                        message: t,
                                        name: i,
                                        stack: o
                                    }
                                }
                            })
                        }
                    }
                }
            }));
        var E = n(71621);
        const x = (0, r.ff)([(0, r.t6)(s.$e, l.u2), E.e, l.PV], ((e, t, n) => {
                const i = t => {
                    Object.entries(e.widgets).forEach((e => {
                        n.dispatch("CONSENT_POLICY_UPDATE", (() => t), {
                            compId: e[0]
                        })
                    }))
                };
                return {
                    pageDidMount: () => t.registerToChanges(i)
                }
            })),
            R = ({
                tpaModal: e,
                tpaPopup: t,
                compId: n = "",
                onCloseMessage: i
            }) => {
                t.isPopup(n) ? t.closePopup(n, i) : e.closeModal(i)
            },
            M = (0, r.ff)([l.R3, a.jn], ((e, t) => ({
                getTpaHandlers: () => ({
                    onEscapeClicked: n => {
                        R({
                            tpaModal: e,
                            tpaPopup: t,
                            compId: n
                        })
                    }
                })
            })));
        var A = n(52506);
        const L = (0, r.ff)([(0, r.t6)(s.R9, d.u2), (0, r.jt)(A.d)], (({
                externalBaseUrl: e
            }, t) => ({
                getTpaHandlers: () => ({
                    async getCustomizedUrlSegments(i, a) {
                        const {
                            url: o,
                            options: r
                        } = a, s = null == t ? void 0 : t.urlMappings, {
                            getCustomizedUrlSegments: p
                        } = await n.e(7482).then(n.bind(n, 47194));
                        return p(s, o, Object.assign({
                            baseUrl: e
                        }, r))
                    }
                })
            }))),
            j = (0, r.ff)([(0, r.t6)(s.R9, d.u2), (0, r.jt)(A.d)], (({
                externalBaseUrl: e
            }, t) => ({
                getTpaHandlers: () => ({
                    async buildCustomizedUrl(i, a) {
                        const {
                            key: o,
                            itemData: r,
                            options: s
                        } = a, p = null == t ? void 0 : t.urlMappings, {
                            buildCustomizedUrl: l
                        } = await n.e(7482).then(n.bind(n, 47194));
                        return l(p, o, r, Object.assign({
                            baseUrl: e
                        }, s))
                    }
                })
            })));
        var k = n(18037),
            $ = n.n(k);
        const _ = /(?:\+|\()?\d(?:[-.() \t\u00a0\u1680\u180e\u2000\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]{0,5}\d){6,16}\)?(?![<@)\w])|\*\d{4}(?![<@)\w])/,
            U = /(^|[\s:;,<>])([A-Z0-9][A-Z0-9._%+-]+@[A-Z0-9][A-Z0-9.-]+\.[A-Z]{2,})(?=$|[\s:;,<>])/i,
            N = /(^|[\s:;,<>])((?:https?:\/\/|www\.)[a-z0-9](?:\.?[a-z0-9\-%_])*(?:(?:\\|\/)[a-z0-9\-._~:/\\?#[\]@!$&'()*+,;=%]*)?)(?=$|[^a-z0-9\-._~:/\\?#[\]@!$&'()*+,;=%])/i,
            H = new RegExp(/(?:^|[\s:;,<>])(?:\+|\()?\d(?:[-.() \t\u00a0\u1680\u180e\u2000\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]{0,5}\d){6,16}\)?(?![<@)\w])|\*\d{4}(?![<@)\w])/, "g"),
            B = /([A-Z0-9][A-Z0-9._%+-]+@[A-Z0-9][A-Z0-9.-]+\.[A-Z]{2,})/gi,
            F = /((?:https?:\/\/|www\.)[a-z0-9](?:\.?[a-z0-9\-%_])*(?:(?:\\|\/)[a-z0-9\-._~:/\\?#[\]@!$&'()*+,;=%]*)?)/gi,
            W = "PHONE",
            V = "MAIL",
            z = "URL",
            G = e => 0 === e.toLowerCase().indexOf("http") ? e : `http://${e}`,
            Z = [" ", ":", ";", ",", "<", ">"],
            Q = {
                [W]: e => {
                    const t = e.match(_);
                    return t && {
                        key: t[0],
                        value: t[0].match(/[*\d]/g).join(""),
                        index: t.index,
                        pattern: W
                    }
                },
                [V]: e => {
                    const t = e.match(U);
                    if (t) {
                        const e = t[1].length,
                            n = t[2];
                        return {
                            key: n,
                            value: n,
                            index: t.index + e,
                            pattern: V
                        }
                    }
                    return null
                },
                [z]: e => {
                    const t = e.match(N);
                    if (t) {
                        const e = t[2],
                            n = t[1].length;
                        return {
                            key: e,
                            value: G(e),
                            index: t.index + n,
                            pattern: z
                        }
                    }
                    return null
                }
            };
        const K = {
                [W]: "tel:",
                [V]: "mailto:",
                [z]: ""
            },
            X = (e, t) => {
                const n = function(e, t = {}) {
                    if (!e) return null;
                    const n = Object.keys(t).filter((e => t[e])).map((t => Q[t](e))).filter((e => null !== e));
                    return n[0] ? n.reduce(((e, t) => t.index < e.index ? t : e), n[0]) : null
                }(e, {
                    MAIL: !0,
                    URL: !0,
                    PHONE: t
                });
                return n && (({
                    pattern: e,
                    value: t
                }) => {
                    const n = e === z ? {
                        target: "_blank"
                    } : {};
                    return Object.assign(Object.assign({}, n), {
                        href: `${K[e]}${t}`
                    })
                })(n)
            },
            q = e => t => {
                let n = "";
                const i = t.trim();
                switch (e) {
                    case "email":
                        n = `href="mailto:${i}"`;
                        break;
                    case "phone":
                        n = `href="tel:${i}"`;
                        break;
                    case "url":
                        n = `href="${G(i)}" target="_blank"`
                }
                return `<a data-auto-recognition="true" ${n}>${t}</a>`
            },
            J = q("email"),
            Y = q("url"),
            ee = q("phone"),
            te = (e, t) => (n, i) => {
                if (!i || !t && i.startsWith("&lt;")) return n;
                let a = (o = J, i.replace(B, o));
                var o;
                return a = ((e, t) => e.replace(F, t))(a, Y), e && (a = ((e, t) => e.replace(H, (e => {
                    const n = Z.find((t => t === e[0]));
                    return n ? n + t(e.substring(1, e.length)) : t(e)
                })))(a, ee)), n.split(i).join(a)
            };
        const ne = ({
                recipient: e,
                subject: t,
                body: n
            }) => {
                const i = Object.entries({
                    subject: t,
                    body: n
                }).filter((([, e]) => e)).map((([e, t]) => `${e}=${t}`)).join("&");
                return `mailto:${e}${i.length>0?`?${i}`:""}`
            },
            ie = ({
                phoneNumber: e
            }) => `tel:${e}`,
            ae = ({
                docId: e,
                name: t,
                indexable: n
            }, i, a, o, r) => {
                const s = new URL(o).hostname.startsWith("editor.wix"),
                    p = e.endsWith("pdf") && r && (e => {
                        const t = new URL(e).hostname;
                        return !t.endsWith(".wixsite.com") && !t.endsWith(".editorx.io")
                    })(o) && !s ? new URL("_files", new URL(o)) : `https://${i}.${a}`,
                    l = e.includes("/") ? e : `ugd/${e}`;
                var d;
                return `${p}${l.startsWith("/")?l:`/${l}`}${e.endsWith(".pdf")?n?"?index=true":"":`?${d={dn:t},Object.keys(d).map((e=>`${e}=${encodeURIComponent(d[e])}`)).join("&")
}
`}`
};
var oe = n(79997);
const re = /^\/([^ ?#]*)?[#]?([^ ?#]*)[?]?(.*)/, se = /^#([^ ?]*)[?]?(.*)/, pe = /^(http|https):\/\/(.*)/, le = /^wix:document:\/\/v1\/(.+)\/(.+)/, de = /^document:\/\/(.*)/, ce = {
top: "SCROLL_TO_TOP",
bottom: "SCROLL_TO_BOTTOM"
}, ue = e => pe.test(e), ge = (e, t) => {
if (e) {
    const [n] = t.replace("#", "/#").split(/[/]+/), i = Object.values(e).filter((e => e.prefix === n));
    return 1 === i.length
}
return !1
}, me = (e, t) => {
const n = $().findKey(e.routes, (e => {
    if ("Dynamic" === e.type) {
        return (e.pageIds || []).includes(t)
    }
    return e.pageId === t
}));
if (n) return he(n);
throw new Error(`No url route for pageId: ${t}`)
}; class fe extends Error {
constructor() {
    super("Unsupported link type"), this.name = "UnsupportedLinkTypeError", Error.captureStackTrace && Error.captureStackTrace(this, fe)
}
}
const he = e => e.replace(/^\.\//, "/"), Ie = e => ["SCROLL_TO_TOP", "SCROLL_TO_BOTTOM"].includes(e), Pe = ({
routingInfo: e,
metaSiteId: t,
userFileDomainUrl: n,
popupPages: i,
getCompIdByWixCodeNickname: a,
getRoleForCompId: o,
routersConfig: r,
multilingualInfo: s,
isMobileView: p,
isPremiumDomain: l
}) => {
const d = `https://${t}.${n}/`,
    c = e => !!i && i[e],
    u = (e, t = "") => `wix:document://v1/${e}/${t}`,
    g = e => {
        var t;
        const [, n = "", i = "", a = ""] = re.exec(e), o = new URLSearchParams(a);
        return (null == s ? void 0 : s.isOriginalLanguage) || "QueryParam" !== (null === (t = null == s ? void 0 : s.currentLanguage) || void 0 === t ? void 0 : t.resolutionMethod) || o.set("lang", s.currentLanguage.languageCode), {
            relativePageUrlPrefix: n,
            anchor: i,
            queryString: o.toString()
        }
    },
    m = (t, n = "_self") => {
        const {
            relativePageUrlPrefix: i = "",
            anchor: o = "",
            queryString: s
        } = g(t), p = ce[o] || o;
        if (c(i)) return {
            type: "PageLink",
            href: "",
            target: "_self",
            linkPopupId: i
        };
        const l = e.externalBaseUrl;
        let d, u, m;
        if (ge(r, i)) {
            m = `./${i}` === e.relativeUrl, d = "DynamicPageLink", u = `${l}/${i}`
        } else {
            const [t, ...n] = i.split("/"), a = n.length > 0 ? `/${n.join("/")}` : "", o = decodeURIComponent(t), r = `./${o}`, s = "./" === r ? {
                pageId: e.mainPageId
            } : e.routes[r];
            d = "PageLink", u = (null == s ? void 0 : s.pageId) === e.mainPageId && !a ? l : `${l}/${o}${a}`, m = s && s.pageId === e.pageId
        }
        const f = p && a && a(p),
            h = m && f,
            I = p && !h;
        return Object.assign(Object.assign({
            href: `${u}${s?`?${new URLSearchParams(s).toString()}`:""}`,
            target: n,
            type: d
        }, h && {
            anchorCompId: f
        }), I && {
            anchorDataId: p
        })
    };
return {
    isAbsoluteUrl: ue,
    isDynamicPage: e => {
        const {
            relativePageUrlPrefix: t
        } = g(e);
        return ge(r, t)
    },
    getImpliedLink: e => X(e, p),
    getImpliedLinks: (e, t) => function(e, t, {
        parseEscaped: n
    } = {
        parseEscaped: !1
    }) {
        return e.replace(/>((?![<>]).+?)<|(?:<a.*>.*<\/a>)/g, te(t, n))
    }(e, p, t),
    getLink: ({
        href: t = "",
        linkPopupId: n,
        anchorCompId: i = "",
        anchorDataId: a = "",
        docInfo: r,
        type: s
    } = {}) => {
        if (n) return `/${n}`;
        if ((0, oe.r5)(t)) return t;
        if ((e => e.startsWith(d))(t)) return u(r.docId, r.name);
        if (Ie(a)) return `#${$().invert(ce)[a]}`;
        if ("ExternalLink" === s) return t;
        const [p] = t.split("?"), l = (null == o ? void 0 : o(i, "wixCode")) || a, c = l ? `#${l}` : "", g = p === e.externalBaseUrl ? (() => {
            const t = $().findKey(e.routes, (t => t.pageId === e.mainPageId));
            return he(t)
        })() : (t => t.replace(e.externalBaseUrl, ""))(p);
        return `${g}${c}`
    },
    getLinkProps: (i, a) => {
        if (o = i, se.test(o)) {
            const t = he(e.relativeUrl);
            return m(`${t}${i}`, a)
        }
        var o;
        if ((e => re.test(e))(i)) return m(i, a);
        if ((0, oe.r5)(i)) return (e => {
            const [, t, n] = oe.eu.exec(e), i = $().escape(t), a = $().escape(n);
            return {
                type: "EmailLink",
                href: ne({
                    recipient: i,
                    subject: a
                }),
                target: "_self"
            }
        })(i);
        if ((0, oe.J1)(i)) return (e => {
            const [, t] = oe.D5.exec(e);
            return {
                type: "PhoneLink",
                href: ie({
                    phoneNumber: t
                }),
                target: "_self"
            }
        })(i);
        if (ue(i)) return ((e, t = "_blank") => ({
            type: "ExternalLink",
            href: e,
            target: t,
            rel: "noopener"
        }))(i, a);
        if ((e => le.test(e) || de.test(e))(i)) return (i => {
            const [, a, o] = le.exec(i) || de.exec(i);
            return {
                type: "DocumentLink",
                href: ae({
                    docId: a,
                    name: o || "",
                    indexable: !1
                }, t, n, e.externalBaseUrl, l),
                target: "_blank",
                docInfo: {
                    docId: a,
                    name: o
                }
            }
        })(i);
        throw new fe
    },
    getLinkUrlFromDataItem: t => {
        const n = {
            AnchorLink: () => {
                const {
                    anchorDataId: n,
                    pageId: i
                } = t, a = Ie(n) ? e.pageId : i.replace(/^#/, ""), o = n.startsWith("#") ? n : `#${n}`;
                return `${me(e,a)}${o}`
            },
            DocumentLink: () => {
                const {
                    docId: e,
                    name: n
                } = t;
                return u(e, n)
            },
            ExternalLink: () => {
                const {
                    url: e
                } = t;
                return e
            },
            DynamicPageLink: () => {
                const {
                    routerId: n,
                    innerRoute: i,
                    anchorDataId: a = "",
                    isTpaRoute: o
                } = t, s = o ? me(e, n) : `/${r[n].prefix}`, p = i ? (e => {
                    const [t, n] = e.split("?");
                    if (n) {
                        const e = encodeURIComponent(`?${n}`);
                        return t ? `${t}${e}` : e
                    }
                    return t
                })(i) : i;
                return `${s}${p?`/${p}${a}`:a}`
            },
            PageLink: () => {
                const {
                    pageId: n
                } = t, i = (("string" == typeof n ? n : n.id) || "").replace(/^#/, "");
                return c(i) ? `/${i}` : i === e.mainPageId ? "/" : me(e, i)
            },
            PhoneLink: () => ie(t),
            EmailLink: () => ne(t)
        }[t.type];
        if (n) return n();
        throw new Error("Provided link type is not supported")
    }
}
};
var ye = n(75471), we = n(19378), Te = n(1640);
const ve = (0, r.ff)([(0, r.t6)(s.R9, d.u2), (0, r.t6)(s.$e, l.u2), (0, r.t6)(s.jC, l.u2), ye.kc, (0, r.jt)(we.wk), (0, r.jt)(Te.HC)], ((e, t, n, i, a, o) => ({
getTpaHandlers: () => ({
    getStateUrl(r, s, {
        originCompId: p
    }) {
        const {
            metaSiteId: l,
            userFileDomainUrl: d,
            routersConfig: c,
            appsClientSpecMapByApplicationId: u,
            externalBaseUrl: g,
            isMobileView: m,
            isPremiumDomain: f,
            experiments: h
        } = e, I = Pe({
            routingInfo: i.getLinkUtilsRoutingInfo(),
            metaSiteId: l,
            userFileDomainUrl: d,
            routersConfig: c,
            popupPages: null == a ? void 0 : a.getPopupPages(),
            multilingualInfo: null == o ? void 0 : o.getMultilingualInfo(),
            isMobileView: m,
            isPremiumDomain: f,
            experiments: h
        }), P = $()(n.pagesData).groupBy("tpaApplicationId").mapValues((e => e.map((e => e.id)))).value(), y = Object.entries(n.pagesData).map((([e, t]) => ({
            [t.tpaPageId]: e
        }))).reduce($().assign), {
            state: w,
            sectionId: T
        } = s, v = (b = p, t.widgets[b].applicationId);
        var b;
        const C = u[v],
            S = P[v];
        if (!S || 0 === S.length) return {
            error: {
                message: `Page with app "${C.appDefinitionName}" was not found.`
            }
        };
        const O = {
                type: "DynamicPageLink",
                routerId: y[T] || S[0],
                isTpaRoute: !0,
                innerRoute: w
            },
            D = I.getLinkUrlFromDataItem(O);
        return I.isDynamicPage(D) ? {
            error: {
                message: "Can't retrieve url for a dynamic page. Please use the platform app API instead."
            }
        } : {
            url: `${g}${D}`
        }
    }
})
}))), be = (0, r.ff)([(0, r.t6)(s.$e, l.u2)], (({
widgets: e
}) => ({
getTpaHandlers: () => ({
    getStyleParamsByStyleId(t, n) {
        const i = Object.values(e).find((e => e.styleId === n.styleId)),
            a = null == i ? void 0 : i.style;
        return a ? Object.assign({}, a) : {
            error: {
                message: `Style id "${n.styleId}" was not found.`
            }
        }
    }
})
})));
var Ce = n(14439), Se = n(31619), Oe = n(11986);
const De = (0, r.ff)([o.Zr, (0, r.t6)(s.R9, d.u2), Se.X, o.ZQ, Ce.U], ((e, {
externalBaseUrl: t
}, n, i, a) => {
const o = e => Object.assign({
        activityDetails: {
            additionalInfoUrl: null,
            summary: ""
        },
        activityInfo: "activityInfo",
        activityType: "activityType",
        contactUpdate: {},
        activityLocationUrl: i.location.href,
        createdAt: (new Date).toISOString()
    }, e),
    r = ((e, t) => n => {
        const i = new URL(t);
        return Object.entries(n.params).forEach((([e, t]) => {
            t && i.searchParams.append(e, t)
        })), e.envFetch(i.href, {
            method: "POST",
            body: JSON.stringify(n.payload),
            headers: {
                "Content-Type": "application/json"
            }
        })
    })(a, `${t}/_api/app-integration-bus-web/v1/activities`);
return {
    getTpaHandlers: () => ({
        postActivity: (0, Oe.u)(["site"], ((t, {
            activity: i
        }, {
            appDefinitionId: a
        }) => {
            var s;
            return (async e => {
                const t = await r(e);
                if (!t.ok) return {
                    status: !1,
                    response: {
                        status: t.status,
                        statusText: t.statusText,
                        responseText: await t.text()
                    }
                };
                const {
                    userSessionToken: i,
                    activityId: a,
                    contactId: o
                } = await t.json();
                return i && n.setUserSession(i), {
                    status: !0,
                    response: {
                        activityId: a,
                        contactId: o
                    }
                }
            })({
                params: (s = {
                    "application-id": a || "TPA",
                    instance: n.getAppInstanceByAppDefId(a)
                }, Object.assign({
                    hs: n.getHubSecurityToken(),
                    "activity-id": "xxxxxxxx".replace(/x/g, (() => (16 * Math.random() | 0).toString(16))),
                    "metasite-id": e.site.metaSiteId,
                    svSession: n.getUserSession(),
                    version: "1.0.0"
                }, s)),
                payload: o({
                    contactUpdate: i.contactUpdate || {},
                    activityInfo: i.info || {},
                    activityType: i.type || "TPA",
                    activityDetails: i.details || {}
                })
            })
        }))
    })
}
})), Ee = (0, r.ff)([Se.X], (e => ({
getTpaHandlers: () => ({
    getCtToken: () => e.getCtToken(),
    getUserSession: () => e.getUserSession()
})
})));
var xe = n(2922);
const Re = (0, r.ff)([ye.Iz, xe.jj, (0, r.t6)(s.R9, d.u2)], ((e, t, {
routersByPrefix: n
}) => ({
getTpaHandlers: () => ({
    getCurrentPageNavigationInfo() {
        const i = e.getRelativeUrl(),
            {
                type: a,
                pageId: o
            } = t.getCurrentRouteInfo();
        if ("Static" === a) return {
            type: "PageLink",
            pageId: o
        };
        const [, r, ...s] = i.split("/"), {
            routerId: p
        } = n[r];
        return {
            type: "DynamicPageLink",
            routerId: p,
            innerRoute: s.join("/") || "/"
        }
    }
})
}))), Me = (0, r.ff)([o.ZQ], (e => ({
getTpaHandlers: () => ({
    getAdsOnPage() {
        const t = e.document.getElementById("WIX_ADS");
        if (!t) return {};
        const {
            height: n,
            width: i,
            x: a,
            y: o
        } = t.getBoundingClientRect();
        return {
            top: {
                height: n,
                width: i,
                top: o,
                left: a
            }
        }
    }
})
})));
var Ae = n(17804), Le = n(60621), je = n(41573);
const ke = (0, r.ff)([(0, r.t6)(s.R9, d.u2), (0, r.t6)(s.$e, l.u2), o.Zr, xe.jj, p.xP, Le.q, l.PV, ye.kc, (0, r.jt)(we.wk), (0, r.jt)(je.Ai), (0, r.jt)(Te.HC)], ((e, t, n, i, a, o, r, s, p, l, d) => ({
getTpaHandlers() {
    const n = (t = s.getLinkUtilsRoutingInfo()) => {
            const {
                metaSiteId: n,
                userFileDomainUrl: i,
                routersConfig: a,
                isMobileView: o,
                isPremiumDomain: r,
                experiments: l
            } = e;
            return Pe({
                routingInfo: t,
                metaSiteId: n,
                userFileDomainUrl: i,
                routersConfig: a,
                popupPages: null == p ? void 0 : p.getPopupPages(),
                multilingualInfo: null == d ? void 0 : d.getMultilingualInfo(),
                isMobileView: o,
                isPremiumDomain: r,
                experiments: l
            })
        },
        i = async ({
            compId: e,
            state: i,
            skipHistory: a,
            queryParams: r = {},
            disableScrollToTop: p = !0
        }) => {
            var l;
            const d = s.getLinkUtilsRoutingInfo(),
                c = n(d),
                {
                    widgets: u
                } = t;
            if (!(null === (l = u[e]) || void 0 === l ? void 0 : l.isSection)) return;
            const g = {
                    type: "DynamicPageLink",
                    routerId: d.pageId,
                    innerRoute: i,
                    isTpaRoute: !0
                },
                m = `${c.getLinkUrlFromDataItem(g)}${$().isEmpty(r)?"":`?appSectionParams=${encodeURIComponent(JSON.stringify(r))}`}`,
                f = c.getLinkProps(m);
            await o.navigateTo(f, {
                skipHistory: a,
                disableScrollToTop: p
            })
        };
    return {
        replaceSectionState: async (e, {
            state: t,
            queryParams: n
        }) => i({
            compId: e,
            skipHistory: !0,
            state: t,
            queryParams: n
        }),
        async appStateChanged(e, {
            state: t
        }) {
            let r;
            try {
                r = JSON.parse(t)
            } catch (e) {
                r = null
            }
            const p = (t, ...n) => {
                    t[Ae.O] ? t({
                        args: n,
                        compId: e
                    }) : t(...n)
                },
                d = t => {
                    const n = a.get(e).onItemClicked;
                    n && p(n, {
                        type: "itemClicked",
                        itemIndex: t,
                        item: a.get(e).images[t]
                    })
                };
            if (!r) return i({
                compId: e,
                skipHistory: !1,
                state: t
            }); {
                const t = {
                    zoom: () => {
                        const [t] = r.args, {
                            id: n
                        } = a.get(e).images[t];
                        l.openImageZoom(e, n), d(t)
                    },
                    itemClicked: () => {
                        const [e] = r.args;
                        d(e)
                    },
                    itemChanged: () => {
                        const [t] = r.args, n = a.get(e).onCurrentItemChanged;
                        n && p(n, {
                            type: "imageChanged",
                            itemIndex: t,
                            item: a.get(e).images[t]
                        })
                    },
                    componentReady: () => {
                        a.update({
                            [e]: {
                                componentReady: !0
                            }
                        })
                    },
                    navigateToDynamicPage: () => {
                        const [e] = r.args, t = n(), i = (e => !e.id && !!(e.href || e.linkPopupId || e.anchorDataId || e.anchorCompId))(e) ? e : t.getLinkProps(t.getLinkUrlFromDataItem(e));
                        o.navigateTo(i)
                    },
                    navigateToAnchor: () => {
                        const [e, t] = r.args, i = {
                            type: "PageLink",
                            pageId: "masterPage" === e ? s.getLinkUtilsRoutingInfo().pageId : e,
                            target: "_self"
                        }, a = n(), p = a.getLinkUrlFromDataItem(i), l = a.getLinkProps(p), d = Object.assign(l, t);
                        o.navigateTo(d)
                    }
                }[r.cmd];
                t && t()
            }
        }
    }
}
})));
var $e = n(54164), _e = n(53891);
const Ue = (0, r.ff)([(0, r.t6)(s.R9, d.u2), $e.s, xe.jj, (0, r.jt)(ye.R1), (0, r.jt)(_e.$)], (({
debug: e
}, t, n, i, a) => ({
getTpaHandlers: () => ({
    applicationLoadingStep(o, r, {
        appDefinitionId: s,
        tpaCompData: {
            widgetId: p
        } = {}
    }) {
        if (u.isRuntimeCompId(o)) return void(e && console.warn(`applicationLoadingStep is ignored in runtime component ${o}`));
        const l = n.getCurrentRouteInfo(),
            d = Date.now() - t.initialRequestTimestamp,
            {
                stage: c,
                stageNum: g
            } = r;
        null == a || a.logger.log({
            appId: s,
            widget_id: p,
            instance_id: o,
            src: 42,
            evid: 644,
            tts: d,
            pid: l ? l.pageId : null,
            stage: c,
            stageNum: g,
            pn: i.getPageNumber()
        }, {
            endpoint: "ugc-viewer"
        })
    }
})
}))), Ne = (0, r.ff)([(0, r.t6)(s.R9, d.u2), $e.s, xe.jj, (0, r.jt)(ye.R1), (0, r.jt)(_e.$)], (({
debug: e
}, t, n, i, a) => ({
getTpaHandlers: () => ({
    applicationLoaded(o, r, {
        appDefinitionId: s,
        tpaCompData: {
            widgetId: p
        } = {}
    }) {
        if (u.isRuntimeCompId(o)) return void(e && console.warn(`applicationLoaded is ignored in runtime component ${o}`));
        const l = n.getCurrentRouteInfo(),
            d = Date.now() - t.initialRequestTimestamp;
        null == a || a.logger.log({
            appId: s,
            widget_id: p,
            instance_id: o,
            src: 42,
            evid: 643,
            tts: d,
            pid: l ? l.pageId : null,
            pn: i.getPageNumber()
        }, {
            endpoint: "ugc-viewer"
        })
    }
})
})));
var He = n(50997);
const Be = (0, r.ff)([He.n9, l.PV], ((e, t) => ({
getTpaHandlers: () => ({
    async refreshCurrentMember() {
        const n = await e.getMemberDetails(!0);
        n && t.dispatch("MEMBER_DETAILS_UPDATED", (() => n))
    }
})
})));
var Fe = n(31191);
const We = (0, r.ff)([a.jn, l.R3], (({
openPopup: e
}, t) => {
const n = e => {
    if (t.isModal(e)) {
        const e = new Error("An app can not open a popup from a modal.");
        return e.name = "Operation not supported", e
    }
    return null
};
return {
    getTpaHandlers: () => ({
        openPopup: (0, Oe.u)(["site", "preview"], ((t, i, {
            originCompId: a
        }) => {
            var {
                url: o
            } = i, r = (0, Fe._T)(i, ["url"]);
            const s = n(t);
            return s ? Promise.reject(s) : e(o, r, a)
        })),
        openPersistentPopup: (0, Oe.u)(["site", "preview"], ((t, i, {
            originCompId: a
        }) => {
            var {
                url: o
            } = i, r = (0, Fe._T)(i, ["url"]);
            const s = n(t);
            return s ? Promise.reject(s) : e(o, Object.assign(Object.assign({}, r), {
                persistent: !0
            }), a)
        }))
    })
}
})), Ve = (0, r.ff)([Se.X], (e => ({
getTpaHandlers: () => ({
    getAppVendorProductId(t, {
        appDefinitionId: n
    }) {
        var i, a;
        const o = null === (i = e.getAppInstanceByAppDefId(n)) || void 0 === i ? void 0 : i.replace(/^[^.]+./, "");
        if (!o) return null;
        return (null === (a = JSON.parse(atob(o))) || void 0 === a ? void 0 : a.vendorProductId) || null
    }
})
})));
var ze = n(52192);
const Ge = e => $().isNumber(e) ? e : NaN, Ze = e => $().parseInt((e || "").toString().split("px")[0]), Qe = e => {
const t = {
    size: 0,
    unit: ""
};
return $().isNumber(e) ? t.size = e : $().isString(e) && (t.unit = (e => {
    const t = /(%)$/.exec(e);
    return t && t[1] ? t[1] : ""
})(e), t.size = (e => {
    const t = /^([0-9]+)/.exec(e);
    return t && t[1] ? parseInt(t[1], 10) : 0
})(e)), t
}, Ke = ({
width: e,
height: t
}, n) => "100%" === t && ("100%" === e || Number(Ze(e)) >= n.innerWidth), Xe = (e, t, n) => {
const i = (0, ze.yF)(t) ? null : t.document.getElementById(n),
    a = i ? i.getBoundingClientRect() : null,
    o = (e => {
        let t = 0,
            n = 0;
        if (e && e.offsetParent) {
            let i = e;
            do {
                t += i.offsetLeft, n += i.offsetTop
            } while (i = i.offsetParent)
        }
        return {
            top: n,
            left: t
        }
    })(i),
    r = {
        left: o.left,
        top: o.top,
        width: a ? Math.round(a.width) : 0,
        height: a ? Math.round(a.height) : 0,
        actualTop: a ? a.top : 0,
        actualLeft: a ? a.left : 0
    },
    s = $().defaults(e.position, {
        x: 0,
        y: 0,
        origin: "FIXED",
        placement: "CENTER"
    }),
    p = $().pick(e, "height", "width"),
    l = {
        width: (0, ze.yF)(t) ? 0 : t.innerWidth,
        height: (0, ze.yF)(t) ? 0 : t.innerHeight
    },
    d = {
        RELATIVE: () => ((e, t, n, i) => {
            const a = function(e, t, n) {
                    return e + t / 2 - n / 2
                },
                o = function(e, t, n) {
                    return e - (t + n)
                },
                r = function(e, t, n) {
                    return e - (t + n)
                },
                s = function(e, t, n) {
                    return e + t / 2 - n / 2
                },
                p = Ge(i.height),
                l = Ge(i.width),
                d = {
                    CENTER: () => ({
                        height: $().min([p, n.height]),
                        width: $().min([l, n.width]),
                        top: s(t.top, t.height, p),
                        left: a(t.left, t.width, l)
                    }),
                    TOP_LEFT: () => ({
                        height: $().min([p, t.top]),
                        width: $().min([l, t.left]),
                        top: t.top - p,
                        left: t.left - l
                    }),
                    TOP_RIGHT: () => ({
                        height: $().min([p, t.top]),
                        width: $().min([l, r(n.width, t.width, t.left)]),
                        top: t.top - p,
                        left: t.width + t.left
                    }),
                    TOP_CENTER: () => ({
                        height: $().min([p, t.top]),
                        width: $().min([l, n.width]),
                        top: t.top - p,
                        left: a(t.left, t.width, l)
                    }),
                    CENTER_RIGHT: () => ({
                        height: $().min([p, n.height]),
                        width: $().min([l, r(n.width, t.width, t.left)]),
                        top: s(t.top, t.height, p),
                        left: t.width + t.left
                    }),
                    CENTER_LEFT: () => ({
                        height: $().min([p, n.height]),
                        width: $().min([l, t.left]),
                        top: s(t.top, t.height, p),
                        left: t.left - l
                    }),
                    BOTTOM_LEFT: () => ({
                        height: $().min([p, o(n.height, t.top, t.height)]),
                        width: $().min([l, t.left]),
                        top: t.top + t.height,
                        left: t.left - l
                    }),
                    BOTTOM_RIGHT: () => ({
                        height: $().min([p, o(n.height, t.top, t.height)]),
                        width: $().min([l, r(n.width, t.width, t.left)]),
                        top: t.top + t.height,
                        left: t.width + t.left
                    }),
                    BOTTOM_CENTER: () => ({
                        height: $().min([p, o(n.height, t.top, t.height)]),
                        width: $().min([l, n.width]),
                        top: t.top + t.height,
                        left: a(t.left, t.width, l)
                    })
                }[e.placement](),
                c = $().max([0, d.top]),
                u = $().max([0, d.left]);
            return Object.assign(Object.assign(Object.assign({}, {
                position: "absolute",
                display: "block",
                width: 0,
                height: 0
            }), d), {
                top: c,
                left: u
            })
        })(s, r, l, p),
        ABSOLUTE: () => ((e, t, n, i) => {
            const a = Ge(i.height),
                o = Ge(i.width),
                r = {
                    CENTER: () => {
                        const i = $().min([t.actualTop + e.y, n.height - (t.actualTop + e.y)]),
                            r = $().min([t.actualLeft + e.x, n.width - (t.actualLeft + e.x)]);
                        return {
                            height: $().min([a, 2 * i]),
                            width: $().min([o, 2 * r]),
                            top: t.top + e.y - a / 2,
                            left: t.left + e.x - o / 2
                        }
                    },
                    TOP_LEFT: () => ({
                        height: $().min([a, t.actualTop + e.y]),
                        width: $().min([o, t.actualLeft + e.x]),
                        top: t.top + e.y - a,
                        left: t.left + e.x - o
                    }),
                    TOP_RIGHT: () => ({
                        height: $().min([a, t.actualTop + e.y]),
                        width: $().min([o, n.width - (t.actualLeft + e.x)]),
                        top: t.top + e.y - a,
                        left: t.left + e.x
                    }),
                    TOP_CENTER: () => {
                        const i = $().min([t.actualLeft + e.x, n.width - (t.actualLeft + e.x)]);
                        return {
                            height: $().min([a, t.actualTop + e.y]),
                            width: $().min([o, 2 * i]),
                            top: t.top + e.y - a,
                            left: t.left + e.x - o / 2
                        }
                    },
                    CENTER_RIGHT: () => {
                        const i = $().min([t.actualTop + e.y, n.height - (t.actualTop + e.y)]);
                        return {
                            height: $().min([a, 2 * i]),
                            width: $().min([o, n.width - (t.actualLeft + e.x)]),
                            top: t.top + e.y - a / 2,
                            left: t.left + e.x
                        }
                    },
                    CENTER_LEFT: () => {
                        const i = $().min([t.actualTop + e.y, n.height - (t.actualTop + e.y)]);
                        return {
                            height: $().min([a, 2 * i]),
                            width: $().min([o, t.actualLeft + e.x]),
                            top: t.top + e.y - a / 2,
                            left: t.left + e.x - o
                        }
                    },
                    BOTTOM_LEFT: () => ({
                        height: $().min([a, n.height - e.y]),
                        width: $().min([o, t.actualLeft + e.x]),
                        top: t.top + e.y,
                        left: t.left + e.x - o
                    }),
                    BOTTOM_RIGHT: () => ({
                        height: $().min([a, n.height - (t.actualTop + e.y)]),
                        width: $().min([o, n.width - (t.actualLeft + e.x)]),
                        top: t.top + e.y,
                        left: t.left + e.x
                    }),
                    BOTTOM_CENTER: () => {
                        const i = $().min([t.actualLeft + e.x, n.width - (t.actualLeft + e.x)]);
                        return {
                            height: $().min([a, n.height - (t.actualTop + e.y)]),
                            width: $().min([o, 2 * i]),
                            top: t.top + e.y,
                            left: t.left + e.x - o / 2
                        }
                    }
                }[e.placement](),
                s = $().max([0, r.top]),
                p = $().max([0, r.left]);
            return Object.assign(Object.assign(Object.assign({}, {
                position: "absolute",
                display: "block",
                width: 0,
                height: 0
            }), r), {
                top: s,
                left: p
            })
        })(s, r, l, p),
        FIXED: () => ((e, t, n) => {
            const i = {
                    position: "fixed",
                    display: "block",
                    width: n.width,
                    height: n.height
                },
                a = Qe(n.height);
            "%" === a.unit ? a.size = $().min([a.size, 100]) : a.size > t.height && (a.unit = "%", a.size = 100);
            const o = Qe(n.width);
            o.size = "%" === o.unit ? $().min([o.size, 100]) : $().min([o.size, t.width]);
            const r = {
                CENTER: () => ({
                    marginLeft: o.size / -2 + (o.unit || "px"),
                    marginTop: "%" === a.unit ? 0 : a.size / -2 + (a.unit || "px"),
                    left: "50%",
                    top: "%" === a.unit ? 0 : "50%"
                }),
                TOP_LEFT: () => ({
                    left: "0px",
                    top: "0px"
                }),
                TOP_RIGHT: () => ({
                    right: "0px",
                    top: "0px"
                }),
                TOP_CENTER: () => ({
                    marginLeft: o.size / -2 + (o.unit || "px"),
                    top: "0px",
                    left: "50%"
                }),
                CENTER_RIGHT: () => ({
                    marginTop: "%" === a.unit ? 0 : a.size / -2 + (a.unit || "px"),
                    top: "%" === a.unit ? 0 : "50%",
                    right: "0px"
                }),
                CENTER_LEFT: () => ({
                    marginTop: "%" === a.unit ? 0 : a.size / -2 + (a.unit || "px"),
                    top: "%" === a.unit ? 0 : "50%",
                    left: "0px"
                }),
                BOTTOM_LEFT: () => ({
                    bottom: "0px",
                    left: "0px"
                }),
                BOTTOM_RIGHT: () => ({
                    bottom: "0px",
                    right: "0px"
                }),
                BOTTOM_CENTER: () => ({
                    marginLeft: o.size / -2 + (o.unit || "px"),
                    left: "50%",
                    bottom: "0px"
                })
            };
            return i.width = o.size + (o.unit || "px"), i.height = a.size + (a.unit || "px"), Object.assign(Object.assign({}, i), r[e.placement]())
        })(s, l, p)
    };
return ((e, t, n) => {
    if (Ze(e.width) < 10 || Ze(e.height) < 10) {
        const e = Qe(n.height);
        e.size = "%" === e.unit ? $().min([e.size, 100]) : $().min([e.size, t.height]);
        const i = Qe(n.width);
        return i.size = "%" === i.unit ? $().min([i.size, 100]) : $().min([i.size, t.height]), {
            position: "fixed",
            display: "block",
            width: `${i.size}${i.unit||"px"}`,
            height: `${e.size}${e.unit||"px"}`,
            marginLeft: `${i.size/-2}${i.unit||"px"}`,
            marginTop: `${e.size/-2}${e.unit||"px"}`,
            left: "50%",
            top: "50%"
        }
    }
    return e
})(d[s.origin](), l, p)
};
var qe = n(51978);
const Je = (0, r.ff)([p.xP, o.ZQ, qe.x, (0, r.t6)(s.R9, d.u2), l.R3], ((e, t, n, i, a) => {
const o = (o, r) => {
    const {
        options: s,
        originCompId: p
    } = e.get(o), l = Object.assign(Object.assign({}, s), r), d = a.isModal(o) ? (e => ["height", "width"].reduce(((t, n) => {
        const i = e[n];
        if (!$().isNil(i)) {
            const {
                unit: e,
                size: a
            } = Qe(i);
            e || (t[n] = a)
        }
        return t
    }), {}))(r) : Xe(l, t, p);
    e.update({
        [o]: {
            styleOverrides: d
        }
    }), n.setSiteScrollingBlocked(i.isMobileView && Ke(d, t), o)
};
return {
    getTpaHandlers: () => ({
        async resizeWindow(t, n, {
            tpaCompData: i
        }) {
            if (u.isRuntimeCompId(t)) o(t, n);
            else if (null == i ? void 0 : i.isPinned) {
                const i = {
                    width: $().isNumber(n.width) ? `${n.width}px` : n.width,
                    height: $().isNumber(n.height) ? `${n.height}px` : n.height
                };
                $().isEqual(i, e.get(t).styleOverrides) || e.update({
                    [t]: {
                        styleOverrides: i
                    }
                })
            }
        },
        heightChanged(t, n, {
            tpaCompData: i
        }) {
            if (u.isRuntimeCompId(t)) o(t, {
                height: n.height
            });
            else {
                if (0 === n.height && !(null == i ? void 0 : i.isPinned)) return;
                e.update({
                    [t]: {
                        heightOverride: n.height,
                        heightOverflow: Boolean(n.overflow)
                    }
                })
            }
        }
    })
}
})), Ye = (0, r.ff)([], (() => ({
getTpaHandlers: () => ({
    onReady: () => Promise.resolve()
})
})));
var et = n(67613);
const tt = (0, r.ff)([(0, r.t6)(s.R9, d.u2), (0, r.t6)(s.$e, l.u2), (0, r.t6)(s.jC, l.u2), Le.q, ye.kc, d.B_, (0, r.jt)(we.wk), (0, r.jt)(Te.HC), (0, r.jt)(et.M$), (0, r.jt)(A.d)], ((e, t, i, a, o, {
getTpaSectionByAppDefinitionId: r
}, s, p, l, d) => ({
getTpaHandlers: () => ({
    async navigateToSectionPage(c, u, {
        originCompId: g,
        appDefinitionId: m
    }) {
        var h;
        const {
            metaSiteId: I,
            userFileDomainUrl: P,
            routersConfig: y,
            appsClientSpecMapData: w,
            appsClientSpecMapByApplicationId: T,
            isMobileView: v,
            isPremiumDomain: b,
            experiments: C
        } = e, S = Object.entries(i.pagesData).reduce(((e, [t, n]) => (e[n.tpaApplicationId] || (e[n.tpaApplicationId] = {}), e[n.tpaApplicationId][n.tpaPageId] = t, e)), {}), O = $()(i.pagesData).groupBy("tpaApplicationId").mapValues((e => e.map((e => e.id)))).value(), D = Pe({
            routingInfo: o.getLinkUtilsRoutingInfo(),
            metaSiteId: I,
            userFileDomainUrl: P,
            routersConfig: y,
            popupPages: null == s ? void 0 : s.getPopupPages(),
            multilingualInfo: null == p ? void 0 : p.getMultilingualInfo(),
            isMobileView: v,
            isPremiumDomain: b,
            experiments: C
        }), {
            sectionIdentifier: {
                sectionId: E,
                noTransition: x = !1,
                appDefinitionId: R,
                queryParams: M = {},
                state: A
            } = {},
            state: L
        } = u, j = L || A, k = R ? w[R].applicationId : (_ = g, t.widgets[_].applicationId);
        var _;
        const U = T[k];
        if (!U) return R ? {
            error: {
                message: "Component was not found."
            }
        } : {
            error: {
                message: `Application with appDefinitionId "${R}" was not found on the site.`
            }
        };
        const N = O[k];
        if (!N || 0 === N.length) return {
            error: {
                message: `Page with app "${U.appDefinitionName}" was not found.`
            }
        };
        const H = E ? S[k][E] : null;
        if (E && !H) return {
            error: {
                message: `App page with sectionId "${E}" was not found.`
            }
        };
        const B = {
                type: "DynamicPageLink",
                routerId: H || N[0],
                innerRoute: j,
                isTpaRoute: !0
            },
            F = await (async e => {
                var t, i;
                const a = null == d ? void 0 : d.urlMappings;
                if (a) {
                    const {
                        buildCustomizedUrl: o
                    } = await n.e(7482).then(n.bind(n, 47194)), {
                        key: r,
                        variables: s,
                        options: p
                    } = (null === (i = null === (t = null == e ? void 0 : e.sectionIdentifier) || void 0 === t ? void 0 : t.customizeTarget) || void 0 === i ? void 0 : i.customUrlData) || {};
                    if (r && s) return o(a, r, s, p)
                }
            })(u) || D.getLinkUrlFromDataItem(B);
        if (D.isDynamicPage(F)) return {
            error: {
                message: "Can't navigate to a dynamic page. Please use the platform app API instead."
            }
        };
        const W = `${F}${$().isEmpty(M)?"":`?appSectionParams=${encodeURIComponent(JSON.stringify(M))}`}`,
            V = D.getLinkProps(W);
        x && l && l.disableNextTransition();
        if (!await a.navigateTo(V)) {
            if (console.warn("You have invoked the navigateToSectionPage() API but you are already on the section page. Please use the pushState() API instead."), !1 === (null === (h = u.sectionIdentifier) || void 0 === h ? void 0 : h.shouldRefreshIframe)) return f;
            const e = r(R || m);
            e && e.rebuildSrc()
        }
        return f
    }
})
}))), nt = (0, r.ff)([o.ZQ, (0, r.t6)(s.$e, l.u2)], ((e, t) => ({
getTpaHandlers: () => ({
    boundingRectAndOffsets(n) {
        const i = {
                offsets: {
                    x: 0,
                    y: 0
                },
                rect: {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0,
                    height: 0,
                    width: 0
                },
                scale: t.siteScale
            },
            a = e.document.getElementById(n);
        if (!a) return i;
        const o = (() => {
                if (!t.isFixedHeader) return 0;
                const n = e.document.getElementById("SITE_HEADER");
                return n && n.getBoundingClientRect().height || 0
            })(),
            r = a.getBoundingClientRect();
        return i.offsets = {
            x: r.left + e.scrollX,
            y: r.top + e.scrollY - o
        }, i.rect = $()(r).pick(["left", "right", "top", "bottom", "height", "width"]).mapValues((e => Math.floor(e))).value(), i.rect.top -= o, i
    }
})
})));
var it = n(47216);
const at = (0, r.ff)([(0, r.t6)(s.$e, l.u2), it.QJ, o.EE], (({
widgets: e
}, t, n) => ({
getTpaHandlers: () => ({
    setPageMetadata: (0, Oe.u)(["site"], (async (i, a, {
        originCompId: o
    }) => {
        if (!e[o] || !e[o].isSection) {
            const e = "Setting a page meta data is possible only to TPA Sections and MultiSections";
            return n.captureError(new Error(e), {
                tags: {
                    feature: "tpa"
                }
            }), {
                error: {
                    message: e
                }
            }
        }
        return await t.setTPAOverrides(a), await t.renderSEO(), null
    }))
})
}))), ot = (0, r.ff)([l.R3], (e => ({
getTpaHandlers: () => ({
    openModal: (0, Oe.u)(["site", "preview"], ((t, {
        url: n,
        theme: i,
        height: a,
        width: o
    }) => e.openModal(n, {
        width: o,
        height: a,
        theme: i
    }, t)))
})
}))), rt = (0, r.ff)([(0, r.t6)(s.R9, d.u2), Le.q, ye.kc, p.QZ, (0, r.jt)(we.wk), (0, r.jt)(Te.HC), (0, r.jt)(et.M$)], ((e, t, n, i, a, o, r) => {
const s = t => {
        const {
            metaSiteId: i,
            userFileDomainUrl: r,
            routersConfig: s,
            isMobileView: p,
            isPremiumDomain: l,
            experiments: d
        } = e, c = Pe({
            routingInfo: n.getLinkUtilsRoutingInfo(),
            metaSiteId: i,
            userFileDomainUrl: r,
            routersConfig: s,
            popupPages: null == a ? void 0 : a.getPopupPages(),
            multilingualInfo: null == o ? void 0 : o.getMultilingualInfo(),
            isMobileView: p,
            isPremiumDomain: l,
            experiments: d
        }), u = c.getLinkUrlFromDataItem(t);
        return c.getLinkProps(u)
    },
    p = ({
        pageId: e,
        anchorId: i,
        noTransition: a
    }) => {
        const o = (({
            pageId: e,
            anchorId: t
        }) => {
            const i = s({
                type: "PageLink",
                pageId: e,
                target: "_self"
            });
            return t && (n.getLinkUtilsRoutingInfo().pageId === e ? i.anchorCompId = t : i.anchorDataId = t), i
        })({
            pageId: e,
            anchorId: i
        });
        return a && r && r.disableNextTransition(), t.navigateTo(o)
    };
return {
    getTpaHandlers: () => ({
        navigateToPage(e, {
            pageId: t,
            anchorId: n,
            noTransition: i
        }) {
            p({
                pageId: t,
                anchorId: n,
                noTransition: i
            })
        },
        navigateTo(e, {
            link: n
        }) {
            if (n.type === P) return;
            const i = s(n);
            t.navigateTo(i)
        },
        async navigateToAnchor(e, {
            anchorId: t
        }) {
            if (!await p({
                    pageId: n.getLinkUtilsRoutingInfo().pageId,
                    anchorId: t
                })) throw new Error(`anchor with id "${t}" was not found on the current page.`);
            return f
        },
        async navigateToComponent(e, {
            compId: t,
            pageId: i,
            noPageTransition: a
        }) {
            const o = i || n.getLinkUtilsRoutingInfo().pageId;
            if (!await p({
                    pageId: o,
                    anchorId: t,
                    noTransition: a
                })) throw new Error(`Page id "${o}" does not contain the component id "${t}".`);
            return f
        }
    })
}
})), st = (0, r.ff)([(0, r.t6)(s.R9, d.u2)], (({
appsClientSpecMapData: e
}) => ({
getTpaHandlers: () => ({
    getApplicationFields: (t, {
        appDefinitionId: n
    }) => e[n].appFields
})
})));
var pt = n(6774), lt = n(39013);
const dt = (0, r.ff)([pt.H, l.PV], ((e, t) => ({
getTpaHandlers: () => ({
    removeEventListener(n, {
        eventKey: i
    }, {
        appDefinitionId: a
    }) {
        i.startsWith(lt.$E) ? e.unsubscribe(a, n, i) : t.unregister(i, n)
    }
})
}))), ct = (0, r.ff)([pt.H], (e => ({
getTpaHandlers: () => ({
    publish(t, n, {
        appDefinitionId: i
    }) {
        e.publish(i, t, n)
    }
})
}))), ut = (0, r.ff)([Se.X, l.PV], ((e, t) => ({
getTpaHandlers: () => ({
    async revalidateSession(n, i, {
        appDefinitionId: a
    }) {
        await e.loadNewSession();
        const o = {
            instance: e.getAppInstanceByAppDefId(a)
        };
        return t.dispatch("INSTANCE_CHANGED", (() => o), {
            appDefinitionId: a
        }), o
    }
})
})));
var gt = n(99825), mt = n(21085);
const ft = (0, r.ff)([(0, r.t6)(s.jC, l.u2), (0, r.t6)(s.$e, l.u2), l.KE, mt.p, p.xP, gt.i], ((e, {
widgets: t
}, n, i, a, {
getFontsConfig: o
}) => ({
getTpaHandlers: () => ({
    appIsAlive(r, s, {
        originCompId: p
    }) {
        const {
            siteColors: l,
            isVisualFocusEnabled: d,
            siteTextPresets: c
        } = e;
        a.update({
            [r]: {
                sentAppIsAlive: !0
            }
        }), n.reportTpaLoadEnd(r);
        const u = t[p] || {
            style: {
                colors: {},
                numbers: {},
                booleans: {},
                fonts: {},
                googleFontsCssUrl: "",
                uploadFontFaces: ""
            }
        };
        return Object.assign({
            fonts: o(),
            commonConfig: i.getCommonConfig(),
            isVisualFocusEnabled: d,
            siteColors: l,
            siteTextPresets: c
        }, u)
    }
})
}))), ht = (0, r.ff)([l.PV, pt.H], ((e, t) => ({
getTpaHandlers: () => ({
    registerEventListener(n, {
        eventKey: i,
        receivePastEvents: a = !1
    }, {
        callId: o,
        tpa: r,
        tpaCompData: {
            widgetId: s = ""
        } = {},
        appDefinitionId: p
    }) {
        if (i.startsWith(lt.$E)) t.handleIframeSubscribe(p, n, {
            eventKey: i,
            isPersistent: a,
            callId: o
        });
        else {
            const t = (e, t) => {
                r.postMessage(JSON.stringify({
                    intent: "addEventListener",
                    eventType: e,
                    params: t
                }), "*")
            };
            e.register(i, n, t, {
                widgetId: s,
                appDefinitionId: p
            })
        }
    }
})
}))), It = (0, r.ff)([l.R3, a.jn], ((e, t) => ({
getTpaHandlers: () => ({
    closeWindow: (n, i) => R({
        tpaModal: e,
        tpaPopup: t,
        compId: n,
        onCloseMessage: i
    })
})
}))), Pt = (0, r.ff)([xe.jj], (e => ({
getTpaHandlers: () => ({
    getCurrentPageId: () => e.getCurrentRouteInfo().pageId
})
})));
var yt = n(7611);
const wt = (0, r.ff)([o.ZQ, (0, r.jt)(yt.FK)], ((e, t) => ({
getTpaHandlers: () => ({
    async scrollTo(n, {
        x: i,
        y: a,
        scrollAnimation: o
    }) {
        if (t)
            if (o) {
                const n = 1,
                    o = 0;
                (await t.getInstance()).runAnimationOnElements("BaseScroll", [e], n, o, {
                    y: a,
                    x: i,
                    callbacks: {
                        onComplete: () => Promise.resolve()
                    }
                })
            } else e.scrollTo(i, a)
    }
})
}))), Tt = (0, r.ff)([o.ZQ], (e => ({
getTpaHandlers: () => ({
    scrollBy(t, {
        x: n,
        y: i
    }) {
        e.scrollBy(n, i)
    }
})
}))), vt = (0, r.ff)([(0, r.t6)(s.$e, l.u2)], (({
widgets: e
}) => ({
getTpaHandlers: () => ({
    getExternalId: (t, n, {
        originCompId: i
    }) => Promise.resolve(e[i].externalId)
})
}))), bt = (0, r.ff)([(0, r.t6)(s.$e, l.u2)], (e => ({
getTpaHandlers: () => ({
    getValue(t, {
        key: n,
        scope: i
    }, {
        originCompId: a
    }) {
        const {
            widgets: o,
            appPublicData: r
        } = e, s = o[a].applicationId, p = "APP" === i ? r[s] : o[a].componentPublicData;
        return p && p[n] ? {
            [n]: p[n]
        } : {
            error: {
                message: `key ${n} not found in ${i} scope`
            }
        }
    }
})
}))), Ct = (0, r.ff)([(0, r.t6)(s.$e, l.u2)], (e => ({
getTpaHandlers() {
    function t(t) {
        const {
            widgets: n,
            appPublicData: i
        } = e;
        return {
            APP: i[n[t].applicationId],
            COMPONENT: n[t].componentPublicData
        }
    }
    return {
        getPublicData: (e, n, {
            originCompId: i
        }) => t(i),
        getValues(e, n, {
            originCompId: i
        }) {
            const {
                scope: a,
                keys: o
            } = n, r = t(i);
            return $().pickBy(r[a], ((e, t) => o.includes(t)))
        }
    }
}
}))), St = (0, r.ff)([(0, r.t6)(s.$e, l.u2)], (e => ({
getTpaHandlers: () => ({
    getStyleId: (t, n, {
        originCompId: i
    }) => e.widgets[i].styleId
})
}))), Ot = (0, r.ff)([(0, r.t6)(s.R9, d.u2)], (e => ({
getTpaHandlers: () => ({
    getViewMode: () => ({
        editMode: e.viewMode
    })
})
}))), Dt = (0, r.ff)([(0, r.t6)(s.R9, d.u2), (0, r.t6)(s.$e, l.u2)], (({
widgetsClientSpecMapData: e
}, {
pageId: t
}) => ({
getTpaHandlers: () => ({
    getComponentInfo(n, i, {
        tpaCompData: {
            widgetId: a = ""
        } = {}
    }) {
        var o, r, s;
        const p = "masterPage" === t;
        return {
            compId: n,
            showOnAllPages: p,
            pageId: p ? "" : t,
            tpaWidgetId: null === (o = e[a]) || void 0 === o ? void 0 : o.tpaWidgetId,
            appPageId: (null === (s = null === (r = e[a]) || void 0 === r ? void 0 : r.appPage) || void 0 === s ? void 0 : s.id) || ""
        }
    }
})
}))), Et = (0, r.ff)([(0, r.t6)(s.$e, l.u2), (0, r.t6)(s.jC, l.u2), (0, r.t6)(s.R9, d.u2)], (({
widgets: e
}, {
pagesData: t
}, {
widgetsClientSpecMapData: n
}) => ({
getTpaHandlers: () => ({
    isAppSectionInstalled(i, {
        sectionId: a,
        appDefinitionId: o
    }, {
        originCompId: r
    }) {
        var s;
        let p = null === (s = e[r]) || void 0 === s ? void 0 : s.applicationId;
        if (o) {
            const e = $().find(n, {
                appDefinitionId: o
            });
            p = (null == e ? void 0 : e.applicationId) || p
        }
        const l = $().filter(t, {
            tpaApplicationId: Number(p)
        });
        return $().some(l, {
            tpaPageId: a
        })
    }
})
}))), xt = (0, r.ff)([l.Cc], (({
getSiteMap: e
}) => ({
getTpaHandlers: () => ({
    getSitePages: async (t, {
        includePagesUrl: n
    }) => (await e()).map((e => Object.assign({
        hide: e.hidden,
        id: $().isString(e.pageId) && e.pageId.replace("#", ""),
        isHomepage: e.isHomePage || !1,
        title: e.title
    }, n && {
        url: e.url
    }))),
    getSiteMap: e
})
}))), Rt = (0, r.ff)([ye.Iz, xe.jj, (0, r.t6)(s.jC, l.u2), (0, r.t6)(s.R9, d.u2), o.ZQ], ((e, t, {
pagesData: n
}, {
externalBaseUrl: i
}, a) => ({
getTpaHandlers: () => ({
    siteInfo() {
        const {
            pageId: o
        } = t.getCurrentRouteInfo(), {
            href: r
        } = e.getParsedUrl(), {
            siteDescription: s,
            siteKeywords: p,
            title: l
        } = n[o];
        return {
            siteDescription: s,
            siteKeywords: p,
            baseUrl: i,
            pageTitle: a.document.title,
            pageTitleOnly: l,
            referer: a.document.referrer,
            url: r
        }
    }
})
}))), Mt = (0, r.ff)([(0, r.t6)(s.R9, d.u2), (0, r.t6)(s.jC, l.u2)], (({
externalBaseUrl: e
}, {
pagesData: t
}) => ({
getTpaHandlers: () => ({
    getSectionUrl(n, {
        sectionIdentifier: i
    }, {
        appClientSpecMapData: a
    }) {
        const o = $().find(t, {
            tpaPageId: i
        });
        return (null == o ? void 0 : o.id) ? {
            url: `${e}/${o.pageUriSEO}`
        } : {
            error: {
                message: `Page with app "${null==a?void 0:a.appDefinitionName}" was not found.`
            }
        }
    }
})
}))), At = (0, r.ff)([l.u5], (e => ({
getTpaHandlers: () => ({
    async setFullScreenMobile(t, {
        isFullScreen: n
    }) {
        e.setFullScreenMobile(t, n)
    }
})
}))), Lt = () => {}, jt = (0, r.ff)([], (() => ({
getTpaHandlers: () => ({
    getSiteRevision: Lt,
    getDeviceType: Lt,
    toWixDate: Lt,
    getCompId: Lt,
    getOrigCompId: Lt,
    getWidth: Lt,
    isInModal: Lt,
    getLocale: Lt,
    getCacheKiller: Lt,
    getTarget: Lt,
    getInstanceId: Lt,
    getSignDate: Lt,
    getUid: Lt,
    getPermissions: Lt,
    getIpAndPort: Lt,
    getDemoMode: Lt,
    getInstanceValue: Lt,
    getSiteOwnerId: Lt,
    getImageUrl: Lt,
    getResizedImageUrl: Lt,
    getAudioUrl: Lt,
    getDocumentUrl: Lt,
    getSwfUrl: Lt,
    getPreviewSecureMusicUrl: Lt,
    getStyleParams: Lt,
    getStyleColorByKey: Lt,
    getColorByreference: Lt,
    getSiteTextPresets: Lt,
    getFontsSpriteUrl: Lt,
    getStyleFontByKey: Lt,
    getStyleFontByReference: Lt,
    getSiteColors: Lt,
    getViewModeInternal: Lt,
    postMessage: Lt,
    getEditorFonts: Lt,
    setUILIBParamValue: Lt,
    removeAppMetadata: Lt,
    setAppMetadata: Lt,
    setColorParam: Lt,
    setStyleParam: Lt,
    resizeComponent: Lt,
    setValue: Lt,
    isSupported: Lt,
    appEngaged: Lt,
    getInstalledInstance: Lt,
    isApplicationInstalled: Lt,
    isCustomApplicationPermissionsGranted: Lt,
    isGroupApplicationPermissionsGranted: Lt,
    setFullWidth: Lt
})
})));
var kt = n(56334);
const $t = (0, r.ff)([(0, r.jt)(kt.I)], (e => ({
getTpaHandlers: () => ({
    reportVisitorActivity: e ? e.reportActivity : () => {}
})
}))), _t = (0, r.ff)([p.QZ, p.xP], ((e, t) => ({
getTpaHandlers: () => ({
    getCurrentPageAnchors: () => $()(e.getEntireStore()).pickBy((({
        componentType: e
    }) => "Anchor" === e)).mapValues(((e, n) => ({
        id: n,
        title: t.get(n).name
    }))).values().sortBy((({
        id: e
    }) => {
        switch (e) {
            case "SCROLL_TO_TOP":
                return 0;
            case "SCROLL_TO_BOTTOM":
                return 1;
            default:
                return 2
        }
    })).value()
})
})));
var Ut = n(77862);
const Nt = (e, t, n) => ({
error: {
    errorCode: e,
    message: t,
    error: n
}
}), Ht = "BAD_REQUEST_ERROR", Bt = "WIX_ERROR", Ft = e => (...t) => window.ApplePaySession ? "function" == typeof e ? e(...t) : void 0 : {
error: {
    errorCode: "APPLE_PAY_IS_NOT_AVAILABLE_ERROR"
}
}, Wt = [jt, ft, ht, It, Pt, wt, Tt, vt, bt, Ct, at, ut, Ot, St, Dt, Et, Rt, ct, dt, xt, st, ot, rt, Be, Mt, nt, Ve, Je, Ye, tt, We, At, $t, ke, Ne, Ue, Me, Ee, Re, be, De, ve, _t, j, L, M, (0, r.ff)([o.Zr], (({
siteAssets: e
}) => ({
getTpaHandlers: () => ({
    applePayInvokeMethod: Ft((async (e, t) => {
        if (!t.methodName) return Nt(Ht);
        switch (t.methodName) {
            case "canMakePayments":
                try {
                    return {
                        result: window.ApplePaySession.canMakePayments()
                    }
                } catch (e) {
                    return Nt(Bt, "ApplePaySession.canMakePayments() failed", e)
                }
            case "supportsVersion":
                try {
                    return {
                        result: window.ApplePaySession.supportsVersion(t.payload.version)
                    }
                } catch (e) {
                    return Nt(Bt, `ApplePaySession.supportsVersion(${t.payload.version}) failed`, e)
                }
            default:
                return Nt(Ht)
        }
    })),
    applePayStartSession: Ft((async (t, {
        paymentRequest: n,
        applePayVersion: i,
        callbackApiId: a
    }, o) => {
        try {
            const t = new window.ApplePaySession(i, n),
                r = await (0, Ut.FR)(e.clientTopology.moduleRepoUrl),
                s = window.document.querySelector(`#${o.originCompId} > iframe`);
            if (!s) return Nt(Bt, `Can not find a TPA iframe with id: ${o.originCompId}`);
            const p = await r.api.request(a, {
                target: s
            });
            t.onvalidatemerchant = async e => {
                const n = await p.onValidateMerchant({
                    validationURL: e.validationURL
                });
                return t.completeMerchantValidation(n)
            }, t.onshippingcontactselected = async e => {
                const n = await p.onShippingContactSelected({
                    shippingContact: e.shippingContact
                });
                return Array.isArray(n.errors) && (n.errors = n.errors.map((e => {
                    return t = e, new window.ApplePayError(t.code, t.contactField, t.message);
                    var t
                }))), t.completeShippingContactSelection(n)
            }, t.onshippingmethodselected = async e => {
                const n = await p.onShippingMethodSelected({
                    shippingMethod: e.shippingMethod
                });
                return t.completeShippingMethodSelection(n)
            }, t.onpaymentauthorized = async e => {
                const n = await p.onPaymentAuthorized({
                    payment: e.payment
                });
                return t.completePayment(n)
            }, t.oncancel = async () => await p.onCancel();
            const {
                canceled: l
            } = await p.onClick();
            if (l) return;
            t.begin()
        } catch (e) {
            return Nt(Bt, null == e ? void 0 : e.message, e)
        }
    }))
})
})))], Vt = {
STATE_CHANGED: "STATE_CHANGED",
INSTANCE_CHANGED: "INSTANCE_CHANGED",
PAGE_NAVIGATION: "PAGE_NAVIGATION",
MEMBER_DETAILS_UPDATED: "MEMBER_DETAILS_UPDATED",
CONSENT_POLICY_UPDATE: "CONSENT_POLICY_UPDATE",
SCROLL: "SCROLL",
QUICK_ACTION_TRIGGERED: "QUICK_ACTION_TRIGGERED",
COMMON_CONFIG_UPDATE: "COMMON_CONFIG_UPDATE"
}, zt = (0, r.ff)([(0, r.t6)(s.Wf, l.u2), (0, r.t6)(s.$e, l.u2), Se.X], ((e, t, n) => {
const i = (t, n, i = (() => !0)) => {
    $().forEach(e.get().registry[t], ((e, a) => {
        if (!e) return;
        const {
            listener: o
        } = e, r = (0, Fe._T)(e, ["listener"]), s = (p = i, $().isFunction(p) ? p : e => {
            const [t] = Object.keys(p);
            return e[t] === p[t]
        });
        var p;
        const l = Object.assign({
            compId: a
        }, r);
        s(l) && o(t, n(l))
    }))
};
return (e => {
    e.update((e => $().merge({}, e, {
        registry: {}
    })))
})(e), {
    pageDidMount: () => n.addLoadNewSessionCallback((({
        results: {
            instances: e
        },
        reason: t
    }) => {
        "expiry" === t && i("INSTANCE_CHANGED", (({
            appDefinitionId: t
        }) => ({
            instance: e[t]
        })))
    })),
    register(n, i, a, o) {
        (e => e in Vt)(n) && e.update((e => $().merge({}, e, {
            registry: {
                [n]: {
                    [i]: Object.assign(Object.assign({}, o), {
                        pageId: t.pageId,
                        listener: a
                    })
                }
            }
        })))
    },
    unregister(t, n) {
        e.update((e => $().set(e, ["registry", t, n], null)))
    },
    dispatch: i
}
}));
var Gt = n(58859);
const Zt = (0, r.ff)([l.TJ, Se.X, o.ZQ], ((e, t, n) => {
const {
    resolver: i,
    promise: a
} = (0, Gt.w)();
return Object.assign(Object.assign({}, e), {
    pageDidMount() {
        i();
        const n = t.addLoadNewSessionCallback(e.refreshAllPopups);
        return () => {
            n(), e.closeNonPersistentPopups()
        }
    },
    async openPopup(...t) {
        if (!(0, ze.yF)(n)) return await a, e.openPopup(...t)
    }
})
}));
var Qt = n(18325);
const Kt = (0, r.ff)([p.xP, p.QZ, (0, r.t6)(s.Wf, l.u2), (0, r.t6)(s.R9, d.u2), (0, r.t6)(s.jC, l.u2), (0, r.t6)(s.$e, l.u2), Se.X, o.ZQ, qe.x, Qt.ku, d.RN, d.ex, pt.H], ((e, t, n, i, a, o, r, s, p, l, d, c, g) => {
const m = {},
    f = e => {
        n.update((t => {
            var n;
            return Object.assign(Object.assign({}, t), {
                tpaPopup: {
                    persistentPopups: e,
                    popups: (null === (n = null == t ? void 0 : t.tpaPopup) || void 0 === n ? void 0 : n.popups) || {}
                }
            })
        }))
    },
    h = e => {
        n.update((t => {
            var n;
            return Object.assign(Object.assign({}, t), {
                tpaPopup: {
                    popups: e,
                    persistentPopups: (null === (n = null == t ? void 0 : t.tpaPopup) || void 0 === n ? void 0 : n.persistentPopups) || {}
                }
            })
        }))
    },
    I = () => $().get(n.get(), ["tpaPopup", "popups"], {}),
    P = () => $().get(n.get(), ["tpaPopup", "persistentPopups"], {}),
    y = new RegExp(u.buildRuntimeCompId("tpapopup-[0-9]+", ".+"));
return {
    isPopup: e => y.test(e),
    refreshAllPopups: () => {
        Object.values(P()).forEach((({
            refreshPopUp: e
        }) => e())), Object.values(m).forEach((({
            refreshPopUp: e
        }) => e()))
    },
    closeNonPersistentPopups: () => Object.values(m).forEach((({
        closePopup: e
    }) => {
        e()
    })),
    openPopup(n, r, y) {
        const {
            isMobileView: w,
            isMobileDevice: T,
            previewMode: v,
            viewMode: b
        } = i, {
            masterPageTpaComps: C
        } = a, {
            widgets: S,
            pageId: O
        } = o;
        return new Promise((async i => {
            const a = u.buildRuntimeCompId(`tpapopup-${Date.now()}`, u.getOriginCompId(y)),
                o = y && t.getContextIdOfCompId(y) || l;
            c.registerTpasForContext({
                contextId: o,
                pageId: O
            }, [a]);
            const D = e => {
                    if (r.persistent) {
                        const e = P();
                        delete e[a], f(e)
                    } else delete m[a], h($().omit(I(), a));
                    t.removeComponentFromDynamicStructure(a), p.setSiteScrollingBlocked(!1, a), r.persistent || g.clearListenersByCompId(a), i(e)
                },
                E = e => /^0(?:px|%)?$/.test(`${e}`),
                x = T && v && !E(r.width) && !E(r.height) ? {
                    position: "fixed",
                    width: "319px",
                    height: "512px",
                    marginLeft: 0,
                    marginTop: 0,
                    boxShadow: "none",
                    left: "50%",
                    transform: "translateX(-50%)",
                    top: 0
                } : {},
                R = Object.assign(Object.assign({}, Xe(r, s, y)), x),
                M = () => {
                    const e = S[y] || C[y];
                    return d.buildSrc(a, O, e, n, {
                        extraQueryParams: {
                            isInPopup: "true",
                            origCompId: y,
                            viewMode: b
                        }
                    })
                },
                A = {
                    options: r,
                    originCompId: y,
                    src: M(),
                    styleOverrides: R,
                    isBareTheme: "BARE" === r.theme,
                    closePopup: D
                };
            e.update({
                [a]: A
            }), p.setSiteScrollingBlocked(w && Ke(R, s), a), await t.addComponentToDynamicStructure(a, {
                components: [],
                componentType: "TPAPopup"
            });
            const L = {
                isPersistent: r.persistent,
                closePopup: D,
                refreshPopUp: () => {
                    (S[y] || C[y]) && e.update({
                        [a]: {
                            src: M()
                        }
                    })
                }
            };
            L.isPersistent ? f(Object.assign(Object.assign({}, P()), {
                [a]: L
            })) : (m[a] = L, h(Object.assign(Object.assign({}, I()), {
                [a]: L
            })))
        }))
    },
    closePopup(e, t) {
        const n = P()[e] || I()[e];
        n && n.closePopup(t)
    },
    getOpenedPopups: () => Object.assign(Object.assign({}, P()), m)
}
})), Xt = (0, r.ff)([(0, r.t6)(s.Wf, l.u2), (0, r.jt)(o.mS), o.Zr], ((e, t, {
siteAssets: n,
mode: {
    debug: i
}
}) => {
const {
    promise: a,
    resolver: o
} = (0, Gt.w)();
e.update((() => Object.assign(Object.assign({}, e.get()), {
    publicApiTPAHandlerState: {
        resolvePublicApiGetter: o,
        waitForAppsToRegister: a
    }
})));
return {
    pageWillUnmount() {
        e.update((() => Object.assign(Object.assign({}, e.get()), {
            publicApiTPAHandlerState: null
        })))
    },
    getTpaHandlers: () => ({
        waitForWixCodeWorkerToBeReady: () => {
            const a = e.get().publicApiTPAHandlerState;
            if (a.wixCodeWorkerReadyPromise) return a.wixCodeWorkerReadyPromise;
            const o = (async () => {
                i && console.warn("getPublicApi() has high performance overhead as we download and execute all apps on site. consider mitigating this by e.g migrating to Wix Blocks or OOI.");
                const [a, o, r] = await Promise.all([(0, Ut.FR)(n.clientTopology.moduleRepoUrl), t.platformWorkerPromise, e.get().publicApiTPAHandlerState.waitForAppsToRegister]), s = await r();
                if (!s.length) {
                    const e = "getPublicApi() rejected since there are no platform apps on page";
                    throw i && console.warn(e), new Error(e)
                }
                return await Promise.all(s.map((e => a.api.request(e, {
                    target: o
                }).then((t => {
                    a.api.set(e, t)
                }))))), {}
            })();
            return e.update((() => Object.assign(Object.assign({}, e.get()), {
                publicApiTPAHandlerState: Object.assign(Object.assign({}, a), {
                    wixCodeWorkerReadyPromise: o
                })
            }))), o
        }
    }),
    getSdkHandlers: () => ({
        publicApiTpa: {
            registerPublicApiGetter: t => {
                var n;
                null === (n = e.get().publicApiTPAHandlerState) || void 0 === n || n.resolvePublicApiGetter(t)
            }
        }
    })
}
}));
var qt = n(63805);
const Jt = (e, t) => {
if ((0, ze.yF)(e)) return;
const n = document.getElementById("site-root");
n && (t ? (n.style.setProperty("overflow-y", "hidden"), n.style.setProperty("height", "0")) : (n.style.removeProperty("overflow-y"), n.style.removeProperty("height")))
}, Yt = "tpaModal", en = (0, r.ff)([(0, r.t6)(s.R9, d.u2), (0, r.t6)(s.jC, l.u2), (0, r.t6)(s.$e, l.u2), (0, r.t6)(s.Wf, l.u2), p.xP, o.ZQ, qe.x, p.QZ, Se.X, Qt.ku, d.RN, d.ex, xe.jj, (0, r.jt)(we.wk)], ((e, {
masterPageTpaComps: t
}, n, i, a, o, r, s, p, l, d, c, g, m) => {
let f = () => {};
const h = e => {
        i.update((t => Object.assign(Object.assign({}, t), {
            tpaModal: Object.assign(Object.assign({}, (null == t ? void 0 : t.tpaModal) || {}), {
                closeModalImpl: e
            })
        })))
    },
    I = e => {
        i.update((t => Object.assign(Object.assign({}, t), {
            tpaModal: Object.assign(Object.assign({}, (null == t ? void 0 : t.tpaModal) || {}), {
                currentModalId: e
            })
        })))
    },
    P = () => $().get(i.get(), ["tpaModal", "closeModalImpl"], (() => {})),
    y = (e, t, n) => {
        const i = {
            width: o.innerWidth,
            height: o.innerHeight
        };
        if (e = Math.min(e, i.width), t = Math.min(t, i.height), !n) {
            const n = i.width - 50,
                a = i.height - 50;
            e >= n && t >= a && (e = n, t = a)
        }
        return {
            width: e,
            height: t
        }
    },
    {
        resolver: w,
        promise: T
    } = (0, Gt.w)();
return {
    pageDidMount() {
        w()
    },
    pageWillUnmount() {
        P()()
    },
    isModal: e => e.startsWith(Yt),
    openModal(i, {
        width: p,
        height: w,
        title: v,
        theme: b
    }, C) {
        if ((0, ze.yF)(o)) return new Promise((() => {}));
        let S;
        const {
            tpaModalConfig: O,
            isMobileDevice: D,
            previewMode: E,
            viewMode: x
        } = e, {
            pageId: R,
            widgets: M
        } = n, {
            wixTPAs: A
        } = O, L = u.buildRuntimeCompId(Yt, u.getOriginCompId(C || R)), j = C && s.getContextIdOfCompId(C) || l;
        c.registerTpasForContext({
            contextId: j,
            pageId: R
        }, [L]), P()(), (0, qt.U)();
        const k = C ? a.get(C) : null,
            $ = A[k ? k.applicationId : null],
            _ = () => {
                const e = y(p, w, $);
                a.update({
                    [L]: {
                        width: e.width,
                        height: e.height
                    }
                })
            };
        return o.addEventListener("resize", _), D && r.setSiteScrollingBlocked(!0, L), new Promise((async n => {
            var c;
            await T;
            const u = null == m ? void 0 : m.getCurrentOrPendingPopupId(),
                O = null === (c = g.getCurrentRouteInfo()) || void 0 === c ? void 0 : c.contextId;
            if (l !== O && "masterPage" !== l && l !== u) return void(e.debug && console.warn(`Tried to open modal but the current context ID: ${O} doesn't equal the modal context ID: ${l}`));
            I(L), h((e => {
                h((() => {})), o.removeEventListener("resize", _), (0, qt.i)(), f(), D && (r.setSiteScrollingBlocked(!1, L), Jt(o, !1)), s.removeComponentFromDynamicStructure(L), a.update({
                    [L]: {
                        src: null,
                        closeModal: () => {}
                    }
                }), null == S || S.focus(), S = null, I(null), n(e)
            })), f = (e => {
                if ((0, ze.yF)(o)) return () => {};
                const t = t => {
                    "Escape" === t.key && e()
                };
                return o.addEventListener("keydown", t), () => o.removeEventListener("keydown", t)
            })(P()), D && "LIGHT_BOX" === b && Jt(o, !0);
            const A = y(p, w, $),
                j = C && (M[C] || t[C]) || {},
                k = d.buildSrc(L, R, j, i, {
                    extraQueryParams: {
                        isInModal: "true",
                        origCompId: C,
                        viewMode: x
                    }
                });
            a.update({
                [L]: {
                    src: k,
                    width: A.width,
                    height: A.height,
                    closeModal: P(),
                    isMobileDevice: D,
                    isPreviewMode: E,
                    title: v,
                    theme: b
                }
            }), S = document.activeElement, await s.addComponentToDynamicStructure(L, {
                components: [],
                componentType: "TPAModal"
            })
        }))
    },
    closeModal(e) {
        P()(e)
    },
    getCurrentModalId: () => $().get(i.get(), ["tpaModal", "currentModalId"], null)
}
}));
var tn = n(67333), nn = n(96114), an = n.n(nn);
const on = (0, r.ff)([tn.r, l.PV, Qt.C9], (({
registerToThrottledScroll: e
}, t, n) => ({
name: "siteScrollDispatch",
pageWillMount() {
    e((e => {
        an().measure((() => {
            t.dispatch("SCROLL", (({
                compId: t
            }) => ((e, t) => {
                const n = window.document.getElementById(t);
                if (!n) return {};
                const i = n.getBoundingClientRect();
                return {
                    x: e.x + i.left,
                    y: e.y + i.top,
                    width: i.width,
                    height: i.height,
                    scrollTop: e.y,
                    scrollLeft: e.x,
                    documentHeight: document.documentElement.clientHeight,
                    documentWidth: document.documentElement.clientWidth
                }
            })(e, t)), {
                pageId: n
            })
        }))
    }))
}
})));
var rn = n(90106), sn = n(60306);
const pn = (0, r.ff)([(0, r.t6)(s.R9, d.u2), (0, r.t6)(s.$e, l.u2), p.xP, o.ZQ, rn.l], (({
widgetsClientSpecMapData: e,
isMobileView: t
}, {
widgets: n
}, i, a, o) => {
const r = e => {
        (e => {
            if ((0, ze.yF)(e)) return;
            ["fullScreenMode"].forEach((e => document.body.classList.add(e)))
        })(a), Jt(a, !0), o.set({
            [`${e}-pinned-layer`]: {
                "z-index": "var(--above-all-z-index) !important"
            }
        }), i.update({
            [e]: {
                iOSVersion: (0, sn.oK)(a),
                isMobileFullScreenMode: !0
            }
        })
    },
    s = e => {
        (e => {
            (0, ze.yF)(e) || document.body.classList.remove("fullScreenMode")
        })(a), Jt(a, !1);
        const t = `${e}-pinned-layer`,
            n = o.getCompStyle(t);
        var r, s;
        o.set({
            [t]: (r = n, s = "z-index", Object.keys(r).reduce(((e, t) => (t !== s && (e[t] = r[t]), e)), {}))
        }), i.update({
            [e]: {
                isMobileFullScreenMode: !1
            }
        })
    };
return {
    setFullScreenMobile(i, a) {
        if (!t) throw new Error("show full screen is only available in Mobile view");
        (t => {
            const i = n[t] || {},
                {
                    appDefinitionId: a
                } = e[i.widgetId] || {};
            return Object.values(h).includes(a)
        })(i) && (a ? r(i) : s(i))
    }
}
})), ln = (0, r.ff)([mt.p, l.PV], ((e, t) => ({
pageDidMount: () => e.registerToCommonConfigChange((e => t.dispatch("COMMON_CONFIG_UPDATE", (() => e))))
}))), dn = (0, r.ff)([l.PV, xe.jj], ((e, t) => ({
appDidLoadPage({
    pageId: n
}) {
    var i, a;
    const o = null === (i = t.getPreviousRouterInfo()) || void 0 === i ? void 0 : i.pageId;
    if (!o || o === n) return;
    const r = {
            fromPage: o,
            toPage: n
        },
        s = null === (a = t.getCurrentRouteInfo().dynamicRouteData) || void 0 === a ? void 0 : a.publicData;
    s && (r.routerPublicData = s), e.dispatch("PAGE_NAVIGATION", (() => r))
}
}))), cn = (e, t) => un(t) && t.templateId || e, un = ({
isResponsive: e,
widgetId: t
}) => e && "14517f3f-ffc5-eced-f592-980aaa0bbb5c" === t, gn = (0, r.ff)([p.xP, (0, r.t6)(s.R9, d.u2), (0, r.t6)(s.$e, l.u2), Se.X, Qt.ku, d.ex, l.nV], ((e, {
widgetsClientSpecMapData: t
}, n, i, a, o, r) => {
const {
    widgets: s,
    tpaInnerRouteConfig: p,
    pageId: l
} = n, d = Object.entries(s).map((([e, t]) => {
    const n = cn(e, t);
    return e !== n && o.registerTpaTemplateId(n, e), n
}));
o.registerTpasForContext({
    contextId: a,
    pageId: l
}, d);
const c = t => {
        const i = r.buildSrc({
            compId: t,
            tpaCompData: s[t],
            pageId: n.pageId,
            tpaInnerRouteConfig: p
        });
        e.update({
            [t]: {
                src: i
            }
        })
    },
    u = () => {
        const e = $().pickBy(s, (({
            widgetId: e,
            isOOI: n
        }) => !n && t[e]));
        Object.keys(e).forEach(c)
    };
return {
    pageDidMount: () => i.addLoadNewSessionCallback((({
        reason: e
    }) => {
        "memberLogin" === e && u()
    })),
    rebuildTpasSrc: u,
    rebuildTpaSrc: c
}
}));
var mn = n(62824);
const fn = (0, r.ff)([l.PV, ye.Iz, (0, r.t6)(s.$e, l.u2), Qt.C9], ((e, t, {
tpaInnerRouteConfig: n
}, i) => ({
async onUrlChange() {
    const a = t.getRelativeUrl(),
        o = (0, mn._)(a.replace(/^\./, ""), n.tpaPageUri),
        r = o ? o.join("/") : "";
    e.dispatch("STATE_CHANGED", (() => ({
        newState: r
    })), {
        pageId: i
    })
}
}))), hn = (0, r.ff)([p.xP, p.QZ, l.PV, xe.jj, o.ZQ, Qt.C9, a.jn, l.e4], ((e, t, n, i, a, o, {
getOpenedPopups: r
}, {
rebuildTpasSrc: s
}) => {
const p = {
    previousCurrency: null
};
return {
    onUrlChange(e) {
        if (!i.getCurrentRouteInfo()) return;
        const t = e.searchParams.get("currency");
        t !== p.previousCurrency && (s(), Object.values(r()).forEach((e => e.refreshPopUp())), p.previousCurrency = t)
    }
}
})), In = (0, r.ff)([(0, r.t6)(s.R9, d.u2), d.RN], (({
widgetsClientSpecMapData: e,
deviceType: t,
isMobileView: n
}, i) => ({
buildSrc({
    compId: n,
    tpaCompData: a,
    pageId: o,
    tpaInnerRouteConfig: r
}) {
    const s = cn(n, a),
        {
            widgetId: p
        } = a,
        {
            widgetUrl: l,
            mobileUrl: d
        } = e[p],
        c = "mobile" === t && d || l,
        u = un(a) ? "masterPage" : o,
        g = {};
    return a.isSection && (g.tpaInnerRouteConfig = r), i.buildSrc(s, u, a, c, g)
},
getDefaultProps(t, i, a) {
    var o;
    const {
        appDefinitionName: r,
        appDefinitionId: s,
        appPage: p,
        allowScrolling: l
    } = e[t];
    return {
        title: null !== (o = p.name) && void 0 !== o ? o : r,
        appDefinitionName: r,
        appDefinitionId: s,
        isMobileView: n,
        allowScrolling: l,
        reportIframeStartedLoading: i,
        reportWidgetUnresponsive: a
    }
}
})));
var Pn = n(27451), yn = n(29360);
const wn = ["TPASection", "TPAMultiSection", "TPAGluedWidget", "TPAWidget"], Tn = (0, r.ff)([(0, r.t6)(s.R9, d.u2), (0, r.t6)(s.$e, l.u2), l.KE, l.nV, d.B_, d.lP, o.EE, (0, r.jt)(l.Wt), (0, r.jt)(d.yA)], (({
widgetsClientSpecMapData: e
}, t, n, i, {
registerTpaSection: a,
unregisterTpaSection: o
}, r, s, p, l) => {
const d = ({
    appDefinitionId: e = "UNKNOWN",
    widgetId: t = "UNKNOWN",
    compId: n,
    reason: i
}) => {
    const a = "IframeTpaDataIntegrityError",
        o = new Error(a);
    o.name = a, s.captureError(o, {
        tags: {
            appDefinitionId: e,
            widgetId: t,
            feature: "tpa",
            methodName: "componentWillMount",
            reason: i
        },
        extra: {
            compId: n
        }
    })
};
return {
    componentTypes: wn,
    componentWillMount(c) {
        const {
            widgets: u,
            tpaInnerRouteConfig: g,
            pageId: m
        } = t, f = u[c.id] || u[(0, yn.is)(c.id)];
        f || d({
            compId: c.id,
            reason: "MISSING_DATA_ITEM"
        });
        const {
            widgetId: h,
            isSection: I,
            appDefinitionId: P,
            templateId: y
        } = f;
        if (!e[h]) return void d({
            appDefinitionId: P,
            widgetId: h,
            compId: c.id,
            reason: "MISSING_FROM_CSM"
        });
        l && l.registerToDataCapsule(y || c.id, P);
        const w = () => i.buildSrc({
            compId: c.id,
            tpaCompData: f,
            pageId: m,
            tpaInnerRouteConfig: g
        });
        if (I) {
            const e = {
                appDefinitionId: P,
                rebuildSrc: () => {
                    const e = w();
                    n.reportTpaLoadStart(c.id, e), c.updateProps({
                        src: e
                    })
                }
            };
            a(c.id, e)
        }
        const T = $().once((() => {
                p && p.reportIframeStartedLoading(c.id)
            })),
            v = w(),
            b = $().once((() => {
                const {
                    appDefinitionName: t,
                    isWixTPA: n
                } = e[h];
                if (n) {
                    const e = new Error("TPA did not send appIsAlive");
                    e.name = "IframeTpaUnresponsive", s.captureError(e, {
                        tags: {
                            appDefinitionId: P,
                            widgetId: h,
                            invalidSrc: !v,
                            feature: "tpa",
                            methodName: "componentWillMount"
                        },
                        extra: {
                            appDefinitionName: t,
                            src: v
                        }
                    })
                }
            })),
            C = i.getDefaultProps(h, T, b),
            S = cn(c.id, f),
            O = r ? r.getCachedProps(S) : {};
        return n.reportTpaLoadStart(c.id, v), c.updateProps(Object.assign(Object.assign(Object.assign({}, C), {
            src: v
        }), O)), () => {
            r && ("masterPage" === m ? r.cacheProps(c.id) : un(f) && r.cacheProps(S, c.getProps())), o(c.id), l && l.unregister(y || c.id)
        }
    }
}
})), vn = (0, r.ff)([(0, r.t6)(s.R9, d.u2), (0, r.t6)(s.$e, l.u2), xe.jj, $e.s, _e.$, ye.R1], (({
widgetsClientSpecMapData: e
}, {
widgets: t
}, n, i, a, o) => ({
reportIframeStartedLoading(r) {
    const {
        widgetId: s,
        templateId: p
    } = t[r] || t[(0, yn.is)(r)], l = n.getCurrentRouteInfo(), d = Date.now() - i.initialRequestTimestamp;
    a.logger.log({
        appId: e[s].appDefinitionId,
        widget_id: s,
        instance_id: null != p ? p : r,
        src: 42,
        evid: 642,
        tts: d,
        pid: l ? l.pageId : null,
        pn: o.getPageNumber()
    }, {
        endpoint: "ugc-viewer"
    })
}
}))), bn = "$TPA$", Cn = {
[I]: ["type", "pageId"],
[P]: ["type", "target", "url"],
[y]: ["type", "anchorName", "anchorDataId", "pageId"],
[w]: ["type", "recipient", "subject"],
[T]: ["type", "phoneNumber"],
[v]: ["type", "phoneNumber"],
[b]: ["type", "docId", "name"],
[C]: ["type", "routerId", "innerRoute", "anchorDataId"],
[S]: ["type", "address"]
};

function Sn(e, t, n, i) {
const a = e.label || "",
    o = !e.isVisible || !1,
    r = e.link ? function(e) {
        const t = $().pick(e.link, Cn[e.link.type]);
        if ($().isObject(t.pageId) && (t.pageId = `#${$().get(t,"pageId.id")}`), t.anchorDataId) {
            const e = $().get(t, "anchorDataId.id", t.anchorDataId);
            t.anchorDataId = "SCROLL_TO_TOP" === e || "SCROLL_TO_BOTTOM" === e ? e : `#${e}`
        }
        return t
    }(e) : {},
    s = $().merge(r, {
        title: a,
        hidden: o
    });
if (!s.type) return {
    type: O,
    hidden: o,
    title: a,
    subPages: s.subPages
};
switch (s.type) {
    default:
        case I:
        case y:
        $().merge(s, On(e, t, n));
    break;
    case b:
            const a = i.getLinkUrlFromDataItem(s),
            o = i.getLinkProps(a);s.url = o.href
}
return s
}

function On(e, t, n) {
var i, a, o, r;
const s = null === (a = null === (i = e.link) || void 0 === i ? void 0 : i.pageId) || void 0 === a ? void 0 : a.pageUriSEO,
    p = {
        isHomePage: (null === (r = null === (o = e.link) || void 0 === o ? void 0 : o.pageId) || void 0 === r ? void 0 : r.id) === t
    };
return s && $().assign(p, {
    url: n + "/" + s
}), p
}

function Dn(e, t, n, i, a) {
const {
    externalBaseUrl: o,
    appsClientSpecMapByApplicationId: r,
    metaSiteId: s,
    userFileDomainUrl: p,
    routersConfig: l,
    isMobileView: d,
    isPremiumDomain: c,
    experiments: u
} = t, g = n.getLinkUtilsRoutingInfo(), m = Pe({
    routingInfo: g,
    metaSiteId: s,
    userFileDomainUrl: p,
    routersConfig: l,
    popupPages: null == i ? void 0 : i.getPopupPages(),
    multilingualInfo: null == a ? void 0 : a.getMultilingualInfo(),
    isMobileView: d,
    isPremiumDomain: c,
    experiments: u
});
return function({
    menuItems: e,
    mainPageId: t,
    baseUrl: n,
    linkUtils: i
}) {
    return $().map(e, (e => {
        const a = Sn(e, t, n, i);
        if (a.type === I || a.type === O) {
            const o = $().map(e.items, (e => Sn(e, t, n, i)));
            $().size(o) > 0 && $().assign(a, {
                subPages: o
            })
        }
        return a
    }))
}({
    menuItems: $().filter(e, (({
        link: e
    }) => ! function(e, t) {
        var n, i;
        if (!t) return !1;
        if (t.type === I) {
            let a = null === (n = t.pageId) || void 0 === n ? void 0 : n.tpaPageId;
            const o = e[null === (i = t.pageId) || void 0 === i ? void 0 : i.tpaApplicationId];
            if (o && a) {
                $().includes(a, bn) && (a = a.substr(0, a.indexOf(bn)));
                const e = $().find(o.widgets, (e => {
                    var t;
                    return (null === (t = e.appPage) || void 0 === t ? void 0 : t.id) === a
                }));
                return null == e ? void 0 : e.appPage.hideFromMenu
            }
        }
        return !1
    }(r, e))),
    mainPageId: g.mainPageId,
    baseUrl: o,
    linkUtils: m
})
}
const En = (0, r.ff)([(0, r.t6)(s.R9, d.u2), ye.kc, Qt.cK, (0, r.jt)(we.wk), (0, r.jt)(Te.HC)], ((e, t, n, i, a) => ({
getSiteMap: async () => Dn(await n.fetchResource("masterPage", "siteMap"), e, t, i, a)
}))), xn = (0, r.ff)([(0, r.t6)(s.R9, d.u2), (0, r.t6)(s.$e, l.u2), p.xP, o.EE], (({
widgetsClientSpecMapData: e
}, t, n, i) => {
const a = {};
return {
    reportTpaLoadStart: (o, r) => {
        var s;
        const {
            widgets: p
        } = t, l = p[o] || p[(0, yn.is)(o)], {
            widgetId: d,
            appDefinitionId: c
        } = l;
        if (!e[d]) return;
        if (!(e[d].isWixTPA && r && (null === (s = n.get(o)) || void 0 === s ? void 0 : s.src) !== r)) return;
        const u = "tpa_iframe_load",
            g = Date.now();
        i.interactionStarted(u, {
            customParams: {
                appDefinitionId: c,
                widgetId: d
            }
        }), a[o] = {
            src: r,
            reportLoadFinished: $().once((() => i.interactionEnded(u, {
                customParams: {
                    appDefinitionId: c,
                    widgetId: d,
                    duration: Date.now() - g
                }
            })))
        }
    },
    reportTpaLoadEnd: e => {
        var t;
        const i = a[e];
        (null == i ? void 0 : i.src) && (null === (t = n.get(e)) || void 0 === t ? void 0 : t.src) === i.src && i.reportLoadFinished()
    }
}
})), Rn = e => {
e(l.nV).to(In), e(l.Wt).to(vn), e(i.j.PageDidMountHandler, l.e4).to(gn), e(Pn.Vx).to(Tn), e(d.XA).to(D), e(a.go, o.CT, i.j.PageWillUnmountHandler).to(Xt), e(i.j.PageDidMountHandler, l.PV).to(zt), e(i.j.AppDidLoadPageHandler).to(dn), e(l.TJ).to(Kt), e(i.j.PageDidMountHandler, a.jn).to(Zt), e(l.Cc).to(En), Wt.forEach((t => {
    e(a.go).to(t)
})), e(i.j.PageDidMountHandler).to(x), e(i.j.PageDidMountHandler, i.j.PageWillUnmountHandler, l.R3).to(en), e(i.j.PageWillMountHandler).to(on), e(l.u5).to(pn), e(i.j.PageDidMountHandler).to(ln), e(ye.bV).to(fn), e(ye.bV).to(hn), e(l.KE).to(xn)
}
}, 62824: function(e, t, n) {
"use strict";
n.d(t, {
_: function() {
    return i
}
});
const i = (e, t) => {
const n = e.split("/"),
    i = n.indexOf(t || "");
if (i < 0 || n[i] !== t) return null;
const [, ...a] = n.splice(i);
return a
}
}
}]);
//# sourceMappingURL=https://static.parastorage.com/services/wix-thunderbolt/dist/tpa.34cc13c4.chunk.min.js.map